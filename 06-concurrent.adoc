== Конкурентное программирование

[quote, Rob Pike]
Concurrency is not parallelism.

Наибольшую популярность язык Go получил благодаря встроенной возможности работы с зелёными потоками, так называемым go-рутинами.

=== Конкурентный доступ к памяти

atomic, mutex, Map


=== Go-рутины

Любой программист, сталкивавшийся с GO слышал, о так называемых go-рутинах и их преимуществах:
- похожи на легковесные потоки
- сравнительно небольшой вес, около 2кб
- возможен запуск большого количества go-рутин

В действительности все эти утверждения верны - поэтому необходимо разобраться детальнее с этим мощным инструментом.

Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.
Горутинами управляет планировщик - является перехватывающим задачи (work-stealing) планировщиком. Изначально был введен еще в Go 1.1. Основная суть работы планировщика заключается в том, что он пытается управлять горутинами Golang, взаимодействовать с потоком ОС и взаимодействовать с ЦП для получения ресурсов системы.
Запустить горутину очень просто:
[source,go]
----
import "fmt"

func VerySimpleFunc(){
  fmt.Println("Hello world")
}

func main() {
  go VerySimpleFunc()
}
----

При вызове `VerySimpleFunc`, ее выполнение происходит асинхронно, относительно выполнения операций в вызвавшем ее потоке.

Важно отметить, что горутины, готовые к исполнению хранятся и выполняются в порядке FIFO(first input, first output). Считается, что горутина готова к исполнению, когда для нее возможно выделить ресурсы системы и место для выполнения, а также имеются права на ее запуск. Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
Как только функция вновь готова к выполнению, она снова попадает в очередь для выполнения.

=== Каналы

Мы познакомились с мощным инструментом - горутины. С другой стороны возникает вопрос, как происходит синхронизация асинхронных действий? Как происходит обмен данными? Для этого в Golang существуют - каналы.

Канал в Golang - это объект связи, позволяющий горутинам обмениваться данными, управлять выполнением. Каналы можно объявить следующим образом:

[source,go]
----
ch1 := make(chan int)            // не буферизированный канал, целых чисел
ch2 := make(chan int, 0)         // не буферизированный канал, целых чисел
ch3 := make(chan *os.File, 100)  // буферизированный канал, указателей на файлы
----

Для передачи данных в канал или, наоборот, из канала применяется операция *<-*. Например, передача данных в канал:

[source,go]
----
ch1 <- 5
----
В данном случае в канал посылается число 5. Получение данных из канала в переменную:

[source,go]
----
someInt := <- ch1
----

Разобравшись с передачей данных. Необходимо понять, как происходит синхронизация выполнения горутин при использовании каналов. Синхронизация гарантируется, тем фактом, что горутина блокируется до того момента, когда из канала будет возможно, чтото прочитать. Иначе говоря, пока канал пустой, горутина не выполняет никаких действий. С другой стороны, отправитель данных в канал тоже блокируется, пока кто либо не прочитает из канала. Такой подход является очень простым и мощным, позволяющим легко управлять потоком выполнения команд. С другой стороны не исключена возможность, блокировки программы, когда выполнение будет заблокировано т.к. писатель и читатель будут заблокированы взаимно.

[source,go]
----
c := make(chan int)  // создание канала
// запускаем, неокторую тяжелую функцию, выполнение которой потребует длительного времени
go func() {
    someHardWork()
    c <- 1  // Отправляем сигнал о завершении
}()
makeSomeGreatWorkToo()
<-c   // ожидаем завершения сортировки
----

Буферизированные каналы в свою очередь позволяют не блокировать писателя, до тех пока не заполнится буфер. Работу буферизированных каналов можно проилюстрировать примером:

[source,go]
----
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1          // Ждем, возможности начать выполнение
    someHardTask(r)   // Ждем, завершения
    <-sem             // Задача завершена, позволяем другим горутинам начать выполнения
}

func MakeAllWork(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)
    }
}

----

Как видно из описанно функции, в данном случае канал позволяет заблокировать асинхронное выполнение задач, когда число единовременно запущенных задач превышает `MaxOutstanding`.

.Однонаправленные каналы

.Возвращение каналов

=== CSP (Communicating sequential processes)

=== Ожидание завершения

WaitGroup, ErrGroup

=== Прерывание пула go-рутин

==== Context
