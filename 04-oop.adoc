== ООП в Go

Вопрос о том является ли Go объектно ориентированным или нет достаточно спорный. Кто-то скажет, что да, кто-то — нет. В целом можно сказать, что Go всё же процедурный язык, а все концепции ООП в нём являются лишь синтаксическим сахаром. Именно из-за этого многие шаблоны, распространённые в ООП языках не всегда применимы в Go. Разрабатывая на Go нужно помнить о том, что

[quote, Rob Pike]
Clear is better than clever.

Не старайтесь скрывать логику программы за сложными конструкциями, оставляйте код максимально чистым и понятным.

=== Методы

Первая ложка сахара, предоставляемая языком — методы. К любому пользовательскому типу (кроме интерфейсов, но об этом позже) можно добавить метод. Для этого в том же пакете, где объявлен тип нужно определить функцию следующего вида:
[source,go]
----
type PowerInt int

func (x PowerInt) Power(n int) (res PowerInt) {
    for res = 1; n > 0; n-- {
        res *= x
    }
    return res
}
----

Полученная функция будет методом типа `PowerInt` и вызвать её можно будет следующим образом:
[source,go]
----
x := PowerInt(2)
fmt.Println(x.Power(8)) // 256
----

Но по сути это будет функция от двух переменных, со специальным префиксом после компиляции, для того, чтобы не было конфликтов в глобальном пространстве имён пакета.

Помимо методов, объявленных на самом типе, можно определить метод на указателе:
[source,go]
----
type PowerInt int

func (x *PowerInt) Power(n int) {
    for y := *x; n > 1; n-- {
        *x *= y
    }
}
----

Тогда этот метод можно вызвать как на указателе, так и на переменной типа `PowerInt`, при этом в момент вызова в функцию будет передан указатель на эту переменную, а значит изменения в методе изменят эту переменную:
[source,go]
----
x := PowerInt(2)
x.Power(8)
fmt.Println(x) // 256
----

=== Наследование

Конечно, говоря объекты, мы подразумеваем совокупность данных и методов. Чаще всего для хранения данных используется структура, к которой добавлены методы. Приведём стандартный пример:
[source,go]
----
type Monster struct {
    HitPoints   int
    AttackBonus int
    ArmorClass  int
}

func (m *Monster) Attack() int {
    return rand.Intn(20) + 1 + m.AttackBonus
}

func (m *Monster) Defence() int {
    return 10 + m.ArmorClass
}
----

Для структур также поддерживается некоторое подобие наследования:
[source,go]
----
type Armadillo struct {
    Monster
    HanukkahBonus bool
}
----

Мы просто включили тип `Monster` в описании структуры `Armadillo`. Таким образом с одной стороны мы добавили в описание поле с типом `Monster` и именем `Monster`. При этом, к полям этого поля можно обращаться без указания `Monster` (если, уровнем выше нет полей с таким же именем):
[source,go]
----
a := Armadillo{}
a.ArmorClass = 3 // ~ a.Monster.ArmorClass = 3
----

Аналогично можно вызывать и методы вложенного типа:
[source,go]
----
a.Attack() // ~ a.Monster.Attack()
----

С другой стороны можно переопределить методы в «наследнике»:
[source,go]
----
func (a Armadillo) Defence() int {
    defence := a.Monster.Defence()
    if a.HanukkahBonus {
        defence += 10
    }
    return defence
}
----

Но, это всего лишь сахар, никакой дополнительной магии здесь не может произойти. Так, например, если мы определим на типе `Monster` другой метод, использующий метод `Defence`, то вызов его на переменной типа `Armadillo` вызовет не переопределённый метод:
[source,go]
----
func (m Monster) CMD() int {
    return m.Defence() + m.AttackBonus
}
----
[source,go]
----
a.HanukkahBonus = true
a.Defence() // 23
a.CMD() // 13
----

Таким образом это больше похоже на композицию, а не наследование. Однако, с помощью интерфейса можно сделать полиморфизм.

=== Интерфейсы и полиморфизм

==== Почему nil != nil?