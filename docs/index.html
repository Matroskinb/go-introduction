<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Бастрыков Евгений">
<title>Введение в язык программирования Go</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Введение в язык программирования Go</h1>
<div class="details">
<span id="author" class="author">Бастрыков Евгений</span><br>
<span id="email" class="email"><a href="mailto:vporoshok@gmail.com">vporoshok@gmail.com</a></span><br>
<span id="revnumber">version 0.1.0,</span>
<span id="revdate">2020-01-31</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_базовый_синтаксис">Базовый синтаксис</a>
<ul class="sectlevel2">
<li><a href="#_hello_world">Hello, World!</a></li>
<li><a href="#_переменные">Переменные</a></li>
<li><a href="#_управление_потоком_выполнения">Управление потоком выполнения</a></li>
<li><a href="#_функции">Функции</a></li>
<li><a href="#_задачи">Задачи</a></li>
</ul>
</li>
<li><a href="#_сложные_типы_данных">Сложные типы данных</a>
<ul class="sectlevel2">
<li><a href="#_структуры">Структуры</a></li>
<li><a href="#_указатели">Указатели</a></li>
<li><a href="#_массивы">Массивы</a></li>
<li><a href="#_срезы">Срезы</a></li>
<li><a href="#_хеш_таблицы">Хеш-таблицы</a></li>
<li><a href="#_каналы">Каналы</a></li>
<li><a href="#_пример_сортировка_вставками">Пример: сортировка вставками</a></li>
<li><a href="#_задачи_2">Задачи</a></li>
</ul>
</li>
<li><a href="#_тестирование">Тестирование</a>
<ul class="sectlevel2">
<li><a href="#_простой_тест">Простой тест</a></li>
<li><a href="#_бенчмарки">Бенчмарки</a></li>
<li><a href="#_вложенные_тесты">Вложенные тесты</a></li>
<li><a href="#_property_based_тесты">Property-based тесты</a></li>
<li><a href="#_задача_оптимизация_сортировки_вставками_бинарным_поиском">Задача: оптимизация сортировки вставками бинарным поиском</a></li>
</ul>
</li>
<li><a href="#_ооп_в_go">ООП в Go</a>
<ul class="sectlevel2">
<li><a href="#_методы">Методы</a></li>
<li><a href="#_наследование">Наследование</a></li>
<li><a href="#_интерфейсы_и_полиморфизм">Интерфейсы и полиморфизм</a></li>
</ul>
</li>
<li><a href="#_пакеты_и_модули">Пакеты и модули</a>
<ul class="sectlevel2">
<li><a href="#_публичные_и_приватные_сущности">Публичные и приватные сущности</a></li>
<li><a href="#_циклические_зависимости">Циклические зависимости</a></li>
<li><a href="#_модули">Модули</a></li>
<li><a href="#_соглашения">Соглашения</a></li>
<li><a href="#_задача_развязать_циклические_зависимости">Задача: развязать циклические зависимости</a></li>
<li><a href="#_стандартные_и_экспериментальные_пакеты">Стандартные и экспериментальные пакеты</a></li>
</ul>
</li>
<li><a href="#_конкурентное_программирование">Конкурентное программирование</a>
<ul class="sectlevel2">
<li><a href="#_go_рутины">Go-рутины</a></li>
<li><a href="#_конкурентный_доступ_к_памяти">Конкурентный доступ к памяти</a></li>
<li><a href="#_csp_communicating_sequential_processes">CSP (Communicating sequential processes)</a></li>
<li><a href="#_ожидание_завершения">Ожидание завершения</a></li>
<li><a href="#_прерывание_пула_go_рутин">Прерывание пула go-рутин</a></li>
</ul>
</li>
<li><a href="#_дополнительно">Дополнительно</a>
<ul class="sectlevel2">
<li><a href="#_обработка_ошибок">Обработка ошибок</a></li>
<li><a href="#_потоки_reader_и_writer">Потоки (reader и writer)</a></li>
<li><a href="#_рефлексия">Рефлексия</a></li>
<li><a href="#_различные_подходы_к_тестированию">Различные подходы к тестированию</a></li>
<li><a href="#_генерация_кода">Генерация кода</a></li>
<li><a href="#_makefile_для_go_проектов">Makefile для Go-проектов</a></li>
<li><a href="#_линтеры_и_другие_инструменты">Линтеры и другие инструменты</a></li>
<li><a href="#_особые_комментарии">Особые комментарии</a></li>
<li><a href="#_сборка_мусора">Сборка мусора</a></li>
</ul>
</li>
<li><a href="#_литература_и_ссылки">Литература и ссылки</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>В курсе рассматриваются базовые концепции языка Go, а также основы конкурентного программирования. Язык Go прост в изучении и при этом имеет широкие возможности для оптимизации программ, написанных на нём. В курсе также рассматриваются вопросы, не относящиеся напрямую к изучению языка, но касающиеся применения этого языка в работе или домашних проектах: соглашения по организации кода, версионирование модулей, тестирование кода и многое другое. Также курс содержит указания на материалы для факультативного изучения с более продвинутыми темами, такими как различные подходы к обработке ошибок, рефлексия, генерация кода.</p>
</div>
<div class="paragraph">
<p>Этот курс предполагает, что читатель уже знаком с каким-нибудь языком программирования, поэтому содержит много сравнений и отсылок к другим языкам. Если вы не знаете ни одного языка программирования, начните с изучения языка Си, тем более, что классическая книга по нему, написанная Керниганом и Ритчи, является примером прекрасного учебника, объясняющего сложные абстракции простым и доступным языком с иллюстрациями на лаконичных и понятных примерах<a href="#kr">[kr]</a>.</p>
</div>
<div class="paragraph">
<p>Для работы с курсом вам понадобится установленный компилятор языка Go, который можно установить, воспользовавшись инструкциями на официальном сайте <a href="https://golang.org/" class="bare">https://golang.org/</a>. Также необходимо умение пользоваться командной строкой. Данный учебный материал выложен в открытом доступе под лицензией <a href="https://github.com/vporoshok/go-introduction/blob/master/LICENSE">MIT</a>. Исходный код находится по адресу <a href="https://github.com/vporoshok/go-introduction" class="bare">https://github.com/vporoshok/go-introduction</a>, версия для чтения — <a href="https://vporoshok.me/go-introduction/" class="bare">https://vporoshok.me/go-introduction/</a>. Если вы нашли ошибку, опечатку или неточность, откройте задачу или Pull Request в репозитории или свяжитесь со мной с помощью электронной почты <a href="mailto:vporoshok@gmail.com">vporoshok@gmail.com</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_базовый_синтаксис">Базовый синтаксис</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Начнём с избитой фразы: «Go является статически компилируемым в машинный код языком с сильной статической типизацией». А теперь давайте по порядку разбираться, что же всё это означает. Если вам и так всё понятно, смело переходите параграфу <a href="#_hello_world">Hello, World!</a>.</p>
</div>
<div class="paragraph">
<p>Вообще компьютер умеет работать только с так называемым машинным кодом, то есть инструкциями для центрального процессора, закодированных в понятные этому процессору коды. При этом одна инструкция языка, например, <code>print("Hello, World")</code> разворачивается в несколько инструкций для процессора. Программа, на каком бы языке она ни была написана в итоге должна превратиться в инструкции, понятные процессору. Но пути этого превращения различны. Языки могут быть <em>компилируемые</em> и <em>интерпретируемые</em>. У компилируемых языков этап превращения исходного кода в инструкции процессора, называемый <em>компиляцией</em>, отделён от этапа исполнения этих инструкций. В интерпретируемых языках это преобразование делается непосредственно перед исполнением. Стоит отметить, что в Go есть сокращённая форма для компиляции и запуска: <code>go run main.go</code>, выглядящая со стороны как запуск интерпретатора.</p>
</div>
<div class="paragraph">
<p>С другой стороны даже процесс компиляции может быть разделён на различные этапы. Так есть языки с <em>виртуальными машинами</em>, такие как Java, Erlang, JavaScript и многие другие. Программы, написанные на этих языках компилируются в инструкции виртуального процессора, который эмулируется соответствующей виртуальной машиной, которая на своём уровне преобразует эти инструкции в понятные физическому процессору. То есть вводится промежуточное представление программы, не зависящее от архитектуры конечного компьютера. С другой стороны промежуточное представление программы может быть и без виртуальной машины, например, многие языки используют промежуточное LLVM-представление.</p>
</div>
<div class="paragraph">
<p>В случае интерпретируемых языков для запуска необходим интерпретатор и все зависимости. Артефакты же компиляции могут быть <em>динамическими</em> или <em>статическими</em>. Статический исполняемый файл содержит все свои зависимости в себе и не требует установки дополнительных пакетов или библиотек на компьютер, где будет исполняться. С другой стороны динамические ссылки в исполняемом файле дают большую гибкость в настройке уже во время исполнения, позволяя подменять части программы динамически подключаемыми библиотеками.</p>
</div>
<div class="paragraph">
<p>Осталась последняя часть фразы: <em>сильная статическая типизация</em>. В любом языке программирования есть типы, как бы от вас это не скрывалось его синтаксисом, при этом указание типов никак не связано с тем является ли система типов языка сильной или слабой, статической или динамической. <em>Сильной</em> системой типов (иногда её также называют строгой) делает ограничение на взаимодействие между типами, например, нельзя сложить строку и число, а в Go нельзя умножить целое число на дробное. Однако, можно выполнить приведение типа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-kt">int</span> <span class="tok-p">=</span> <span class="tok-mi">12</span>
<span class="tok-kd">var</span> <span class="tok-nx">y</span> <span class="tok-kt">float64</span> <span class="tok-p">=</span> <span class="tok-mf">2.2</span>

<span class="tok-kd">var</span> <span class="tok-nx">res</span> <span class="tok-kt">float64</span> <span class="tok-p">=</span> <span class="tok-nb">float64</span><span class="tok-p">(</span><span class="tok-nx">x</span><span class="tok-p">)</span> <span class="tok-o">+</span> <span class="tok-nx">y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Также как и с компиляцией, преобразование типов операндов производится в любом языке, но в слабо типизированных языках есть набор правил, по которым компилятор или интерпретатор может выполнить часть преобразований без явных инструкций со стороны программиста. Несмотря на то, что это похоже на то, как мы думаем, ведь написанное на бумаге «426» мы без труда интерпретируем и как строку и как число, хоть целое, хоть вещественное, часто такие неявные правила приводят к трудно обнаружимым ошибкам ошибкам.</p>
</div>
<div class="paragraph">
<p><em>Динамическая</em> и <em>статическая</em> типизация также различается ограничениями, так при статической типизации тип приписывается переменной один раз и не может быть изменён. Например, следующий код допустим в Python (сильная динамическая типизация), но не допустим в Go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-n">x</span> <span class="tok-o">=</span> <span class="tok-s2">&quot;foo&quot;</span>
<span class="tok-n">x</span> <span class="tok-o">=</span> <span class="tok-mi">5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Все приведённые выше развилки имеют достоинства и недостатки с обоих сторон. Нельзя сказать, что компилируемые языки лучше или хуже интерпретируемых. Для некоторых задач что-то больше подходит, что-то меньше. Из своего опыта могу лишь сказать, что в долгосрочной перспективе компиляция и строгая статическая типизация помогают уберечься от глупых ошибок, хоть по началу и требуют больше времени для написания кода.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Пара слов о рантайме</div>
<div class="paragraph">
<p>Стоит заметить также, что Go имеет так называемый рантайм (runtime), функциональность, которая добавляется в любую программу при компиляции. Поэтому даже просто hello world в скомпилированном виде имеет размер почти 2 МБ (1968 КБ для версии 1.12.10 linux/amd64). Для чего же нужен этот дополнительный багаж?</p>
</div>
<div class="paragraph">
<p>Во-первых, в рантайм встроен сборщик мусора, освобождающий память, от неиспользуемых переменных. Это значительно облегчает написание кода, в сравнении с низкоуровневыми языками, такими как Си и C++. разработчик не должен сам следить за использованием памяти, вызывая вручную примитивы типа <code>malloc</code> и <code>mfree</code>, хотя для оптимизации высоконагруженных мест Go позволяет переходить к ручному управлению памятью.</p>
</div>
<div class="paragraph">
<p>Во-вторых, рантайм отвечает также за переключение между go-рутинами, позволяя оптимально распределять ресурсы системы под выполняемые задачи. Более подробно про go-рутины и конкурентную модель выполнения Go вы можете прочитать в <a href="#_конкурентное_программирование">соответствующей главе</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world">Hello, World!</h3>
<div class="paragraph">
<p>Продолжим следовать избитым клише и первой программой будет «Привет, Мир!». Создайте файл с именем <code>main.go</code> со следующим содержимым:</p>
</div>
<div class="listingblock">
<div class="title">01_hello_world/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Hello, World!&quot;</span><span class="tok-p">)</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, если выполнить в командной строке (в директории с файлом <code>main.go</code>) команду</p>
</div>
<div class="listingblock">
<div class="content">
<pre>go run main.go</pre>
</div>
</div>
<div class="paragraph">
<p>вы должны увидеть вывод нашей программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello, World!</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Все примеры, используемые в данном курсе, можно найти в директории examples в репозитории проекта <a href="https://github.com/vporoshok/go-introduction" class="bare">https://github.com/vporoshok/go-introduction</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Давайте разбираться с тем, что происходит в этой короткой программе. Первая не закомментированная строка любого go-файла должна задавать имя пакета, которому этот файл принадлежит. Более подробно о пакетах мы поговорим соответствующей <a href="#_пакеты_и_модули">части</a>, пока же упомянем лишь следующее:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Пакетом является директория, то есть все файлы, расположенные в одной директории (за исключением тестов), должны принадлежать одному пакету. Таким образом не нужно явно подключать файл, находящийся рядом, как в том же Python или NodeJS.</p>
</li>
<li>
<p>Внутри пакета доступны все объявления. То есть нельзя в двух соседних файлах объявлять функции, типы или константы с одинаковыми именами.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Также как в языке Си, исполняемая программа должна содержать функцию <code>main</code>, с которой и начинается исполнение программы. Инструкции за пределами функций, за исключением объявления глобальных переменных, запрещены. Но есть одно ограничение: функция <code>main</code> должна располагаться в пакете <code>main</code>. При этом хорошим тоном считается держать весь код этого пакета в одном файле, так чтобы было удобнее запускать и компилировать программу. На первых порах мы будем оперировать только такими файлами-пакетами, позже мы научимся разбивать код на пакеты и библиотеки.</p>
</div>
<div class="paragraph">
<p>В строке 3 подключается стандартный пакет <code>fmt</code>. Этот пакет содержит функции по работе с вводом/выводом и другие вспомогательные функции. В данном случае в 6-й строке мы используем функцию <code>Println</code> из этого пакета, позволяющую вывести на экран текст.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Тулинг</div>
<div class="paragraph">
<p>С самой первой версии компилятор <code>go</code> содержит специальную команду: <code>go fmt</code>, с помощью которой можно привести код на Go к стандарту оформления. Это оказалось революционным решением, раз и навсегда положившим конец спорам Tab vs Space и исключившее написание условий и циклов без фигурных скобок. Часть сообщества, конечно, восприняли идею общего стиля кода в штыки, но к настоящему моменту большинство одобряет такой подход. Помимо встроенной команды форматирования со временем появились и более продвинутые утилиты, которые не только форматируют код, но и сами добавляют недостающие импорты и даже пропущенные пустые значения в инструкциях выхода из функций, например, <a href="https://godoc.org/golang.org/x/tools/cmd/goimports"><code>goimports</code></a> и <a href="https://github.com/sqs/goreturns"><code>goreturns</code></a>.</p>
</div>
<div class="paragraph">
<p>Кроме автоматического форматирования компилятор из коробки умеет запускать тесты и бенчмарки, позволяя без сторонних утилит разрабатывать сложные библиотеки и программы. Про это мы поговорим в <a href="#_тестирование">соответствующей главе</a>.</p>
</div>
<div class="paragraph">
<p>Также для языка быстро начал расти арсенал статического анализа кода, направленного как на предотвращение ошибок, так и на ужесточение стиля кода. Первым и классическим линтером для языка стал <a href="https://github.com/golang/lint"><code>golint</code></a>. После этого сообщество создало огромное число анализаторов. О том как лучше запускать этот зоопарк для вашего кода описано в дополнении <a href="#_линтеры_и_другие_инструменты">Линтеры и другие инструменты</a>.</p>
</div>
<div class="paragraph">
<p>Но прежде чем двигаться дальше необходимо зафиксировать несколько моментов, способных вызвать проблемы на старте изучения языка.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Отступ строк формируется табуляцией;</p>
</li>
<li>
<p>Название переменных, типов и функций принято писать в camelCase;</p>
</li>
<li>
<p>Фигурные скобочки обязательны, и их принято расставлять в египетском стиле:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>func declaration, for or if {
    body
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Висящая запятая обязательна:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>x := []int{
    1,
    2,
    3,
}</pre>
</div>
</div>
<div class="paragraph">
<p>Без запятой после <code>3</code> компилятор будет ругаться. Аналогично при переносе любых скобок в определении или вызове функции. Вообще, если сомневаетесь — ставить запятую или нет — ставьте, если она не нужна, то <code>go fmt</code> её удалит.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_переменные">Переменные</h3>
<div class="paragraph">
<p>Переменные можно объявлять следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Это создаст переменную с именем <code>x</code> типа <code>int</code> (то есть целое знаковое число). Эту строку можно прочитать как: «пусть <code>x</code> — переменная типа <code>int</code>». Если необходимо объявить несколько переменных, то можно сгруппировать определения с помощью скобок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-p">(</span>
    <span class="tok-nx">x</span> <span class="tok-kt">int</span>
    <span class="tok-nx">s</span> <span class="tok-kt">string</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В случае, когда необходимо определить несколько переменных одного типа, то их можно сгруппировать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span><span class="tok-p">,</span> <span class="tok-nx">z</span> <span class="tok-kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные будут сразу же инициализирована пустыми значением, соответствующими их типам (в данном случае 0). Можно задать другое значение для инициализации:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-kt">int</span> <span class="tok-p">=</span> <span class="tok-mi">17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта строка будет аналогична строкам:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-kt">int</span>
<span class="tok-nx">x</span> <span class="tok-p">=</span> <span class="tok-mi">17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Более того в данном случае компилятор может сам определить тип по константе справа, так что запись можно сократить до</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-p">=</span> <span class="tok-mi">17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для таких случаев в Go предусмотренна короткая запись, эквивалентная написанной выше:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-mi">17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Операция <code>:=</code> объявляет и инициализирует переменную слева от себя значением правой части. В Go запрещено дважды объявлять переменную, поэтому последующие присвоения необходимо делать с помощью оператора <code>=</code>.</p>
</div>
<div class="paragraph">
<p>Также как обычное присвоение <code>=</code> операция объявления может сопоставлять кортежи:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span><span class="tok-p">,</span> <span class="tok-nx">s</span> <span class="tok-o">:=</span> <span class="tok-mi">17</span><span class="tok-p">,</span> <span class="tok-mf">19.5</span><span class="tok-p">,</span> <span class="tok-s">&quot;hello&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате будут объявлены три переменные</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>x</code> типа <code>int</code> со значением 17;</p>
</li>
<li>
<p><code>y</code> типа <code>float64</code> со значением 19.5;</p>
</li>
<li>
<p><code>s</code> типа <code>string</code> со значением "hello";</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Особенностью такого объявления является то, что в левой части могут быть уже объявленные переменные (кроме первой):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">s</span> <span class="tok-kt">string</span>
<span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span><span class="tok-p">,</span> <span class="tok-nx">s</span> <span class="tok-o">:=</span> <span class="tok-mi">17</span><span class="tok-p">,</span> <span class="tok-mf">19.5</span><span class="tok-p">,</span> <span class="tok-s">&quot;hello&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае переменные <code>x</code> и <code>y</code> будут объявлены во второй строке, а переменной <code>s</code> просто будет присвоено значение, то есть этот код эквивалентен следующему:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">s</span> <span class="tok-kt">string</span>
<span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-mi">17</span>
<span class="tok-nx">y</span> <span class="tok-o">:=</span> <span class="tok-mf">19.5</span>
<span class="tok-nx">s</span> <span class="tok-p">=</span> <span class="tok-s">&quot;hello&quot;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_скалярные_типы_данных">Скалярные типы данных</h4>
<div class="paragraph">
<p>Будем называть тип данных <em>скалярным</em>, если значение этого типа нельзя модифицировать, можно лишь присвоить новое значение. То есть мы не можем изменить число, но можем присвоить переменной, содержащей число новое значение. Понятнее это определение станет в <a href="#_сложные_типы_данных">следующей части</a>. Пока же перечислим базовые скалярные типы данных:</p>
</div>
<div class="paragraph">
<p>Числа <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>unit16</code>, <code>uint32</code>, <code>uint64</code>, <code>float32</code>, <code>float64</code>. Как видно все типы имеют в названии размер, занимаемой памяти в битах. Для всех чисел пустое значение — 0. Также любой числовой тип можно привести к любому другому числовому типу, использовав тип как функцию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-kt">int32</span>
<span class="tok-nx">y</span> <span class="tok-o">:=</span> <span class="tok-mf">19.5</span>
<span class="tok-nx">x</span> <span class="tok-p">=</span> <span class="tok-nb">int32</span><span class="tok-p">(</span><span class="tok-nx">y</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>С числами можно производить следующие бинарные арифметические операции: сложение (<code>+</code>), вычитание (<code>-</code>), умножение (<code>*</code>), деление (<code>/</code>), а для целых чисел также доступна операция деления по модулю (<code>%</code>). Кроме того для знаковых типов можно инвертировать знак с помощью приписывания к числу слева знака <code>-</code>. Для всех бинарных операций есть краткая форма записи в случае, если результат необходимо присвоить переменной, являющейся первым операндом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">x</span> <span class="tok-o">+=</span> <span class="tok-mi">2</span> <span class="tok-c1">// эквивалентно x = x + 2</span>
<span class="tok-nx">x</span> <span class="tok-o">%=</span> <span class="tok-mi">3</span> <span class="tok-c1">// эквивалентно x = x % 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Также существуют операции инкрементирования и декрементирования:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">x</span><span class="tok-o">++</span> <span class="tok-c1">// эквивалентно x += 1</span>
<span class="tok-nx">x</span><span class="tok-o">--</span> <span class="tok-c1">// эквивалентно x -= 1</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Операция присваивания в Go не имеет собственного результата, поэтому нельзя использовать присваивание как часть другой инструкции. Это же относится и к сокращённым формам бинарных операций.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Есть также типы алиасы к числовым типам. Например, тип <code>byte</code> является тем же типом <code>int8</code>, а <code>rune</code> — <code>int32</code>. Но есть и менее предсказуемые типы <code>int</code> и <code>uint</code>, являющиеся алиасами к типам <code>int32</code> и <code>uint32</code> или <code>int64</code> и <code>uint64</code> соответственно в зависимости от битности операционной системы, на которой выполняется программа.</p>
</div>
<div class="paragraph">
<p>Булевый тип <code>bool</code> может принимать значение <code>true</code> или <code>false</code>, последнее является пустым значением для этого типа. Для булевых переменных и констант доступны следующие операции: инверсия (<code>!</code>), логическое <strong>и</strong> (<code>&amp;&amp;</code>) и логическое <strong>или</strong> (<code>||</code>).</p>
</div>
<div class="paragraph">
<p>И, наконец, скалярным типом в Go является строка (тип <code>string</code>). Вообще говоря строка представляет из себя срез (<code>slice</code>), о которых мы будем говорить позже. Но компилятор не позволяет модифицировать отдельные символы строки, так что она подходит под определение скалярного типа. Пустым значением для переменных типа строка является пустая строка. Для объявления строковых констант можно использовать либо двойные кавычки (<code>"</code>), либо обратные кавычки (<code>`</code>), при этом в первых можно использовать специальные символы, такие как <code>\n</code>, <code>\t</code> и так далее, а в обратных кавычках можно использовать непосредственно переносы строк. То есть следующие две константы равны:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">s1</span> <span class="tok-o">:=</span> <span class="tok-s">&quot;foo\nbar&quot;</span>
<span class="tok-nx">s2</span> <span class="tok-o">:=</span> <span class="tok-s">`foo</span>
<span class="tok-s">bar`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Строки можно складывать (конкатенировать), используя операцию <code>+</code>. А также можно использовать <a href="#_срезы">синтаксис срезов</a> для получения подстроки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Hello, World!&quot;</span><span class="tok-p">[</span><span class="tok-mi">3</span><span class="tok-p">:</span><span class="tok-mi">5</span><span class="tok-p">]</span> <span class="tok-o">+</span> <span class="tok-s">&quot;l&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_константы">Константы</h4>
<div class="paragraph">
<p>Для всех скалярных типов можно также определить константу с помощью ключевого слова <code>const</code>. Объявление аналогично определению с ключевым словом <code>var</code>, но полученный объект нельзя использовать в левой части оператора присваивания. Также во время объявления констант доступно ключевое слово <code>iota</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Foo</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span>
    <span class="tok-nx">Bar</span>
    <span class="tok-nx">Baz</span>
    <span class="tok-nx">Qux</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В результате будет объявлены следующие константы типа <code>int</code>: <code>Foo</code> равная 0, <code>Bar</code> равная 1, <code>Baz</code> равная 2 и <code>Qux</code> равная 3. При этом <code>iota</code> в рамках одного блока определений будет принимать значения от 0 до максимума типа <code>int</code>, увеличиваясь для каждого следующего определения. Для констант можно задать тип, отличный от <code>int</code>, а с <code>iota</code> можно составить выражение, допустимое в определении констант:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Foo</span> <span class="tok-kt">uint32</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span> <span class="tok-o">*</span> <span class="tok-kc">iota</span>
    <span class="tok-nx">Bar</span>
    <span class="tok-nx">Baz</span>
    <span class="tok-nx">Qux</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой встроенный итератор можно использовать как некоторую замену отсутствующему в языке <code>enum</code>'у, но в придачу к <code>iota</code> понадобится <a href="#_генерация_кода">Генерация кода</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_область_видимости">Область видимости</h4>
<div class="paragraph">
<p>Областью видимости переменной называется область кода, где доступно значение этой переменной. Всегда есть глобальная область видимости пакета, туда попадают константы, функции, типы и переменные, объявленные вне функций. Глобальную переменную можно объявить только с использованием ключевого слова <code>var</code>. То есть можно написать</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">x</span> <span class="tok-p">=</span> <span class="tok-mi">17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>но нельзя использовать оператор <code>:=</code>.</p>
</div>
<div class="paragraph">
<p>Более узкую область видимости определяют функции. В теле функции доступны переменные, объявленные в глобальной области, а также переменные, объявленные в этом же теле функции выше. При этом локальные переменные могут перекрывать внешние, то есть следующий код</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">s</span> <span class="tok-p">=</span> <span class="tok-s">&quot;foo&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-kd">var</span> <span class="tok-nx">s</span> <span class="tok-p">=</span> <span class="tok-s">&quot;bar&quot;</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">s</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Выведет строку <code>"bar"</code>, при этом значение глобальной переменной останется прежним. Некоторые особенности области видимости функций подробнее будут рассмотрены в <a href="#_функции">соответствующем параграфе</a>.</p>
</div>
<div class="paragraph">
<p>Помимо функций, вложенные области видимости задают все конструкции, управляющие потоком выполнения.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_управление_потоком_выполнения">Управление потоком выполнения</h3>
<div class="paragraph">
<p>Для управления потоком выполнения в Go предусмотренны следующие конструкции:</p>
</div>
<div class="sect3">
<h4 id="_условия">Условия</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">if</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">1</span><span class="tok-p">&gt;</span> <span class="tok-p">{</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">1</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">2</span><span class="tok-p">&gt;</span> <span class="tok-p">{</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">2</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">3</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Если выполнено условие <code>&lt;condition 1&gt;</code>, то будут выполнены инструкции, перечисленные в <code>&lt;body 1&gt;</code>, если не выполнено условие <code>&lt;condition 1&gt;</code>, но выполнено условие <code>&lt;condition 2&gt;</code>, то будут выполнены инструкции из <code>&lt;body 2&gt;</code>, наконец, если ни одно условие не выполнено, то будут выполнены инструкции из блока <code>else</code> (<code>&lt;body 3&gt;</code>). Блоков <code>else if</code> может быть сколько угодно от 0 и до бесконечности. Блок <code>else</code> может быть пропущен.</p>
</div>
<div class="paragraph">
<p>В качестве условий могут быть использованы любые выражения, результатом которых имеет тип <code>bool</code>, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">if</span> <span class="tok-nx">x</span> <span class="tok-p">&lt;</span> <span class="tok-mi">0</span> <span class="tok-o">||</span> <span class="tok-nx">x</span> <span class="tok-p">&gt;</span> <span class="tok-mi">100</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Неверно задано значение x&quot;</span><span class="tok-p">)</span>
<span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-nx">x</span> <span class="tok-o">==</span> <span class="tok-mi">0</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;x равен нулю&quot;</span><span class="tok-p">)</span>
<span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;x равен&quot;</span><span class="tok-p">,</span> <span class="tok-nx">x</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Вообще некоторые считают плохим тоном использование ключевого слова <code>else</code>, предпочитая делать ранний выход из функции. Это не особо относится к изучению синтаксиса языка, но может качественно сказаться на читаемости вашего кода. В любом случае рекомендуем прочитать книгу «Чистый код»<a href="#cc">[cc]</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В Go есть особая форма конструкции <code>if</code>, позволяющая выполнить инструкцию прямо внутри условия. Для примера рассмотрим следующую задачу: дана хеш таблица <code>m</code>, необходимо проверить наличие в ней ключа, если ключ есть, то вернуть значение по этому ключу, иначе вернуть <code>defaultValue</code> (аналог метода <code>get</code> словарей в Python). Подробнее о хеш-таблицах мы поговорим в <a href="#_хеш_таблицы">соответствующем разделе</a>, здесь отметим лишь то, что при получении значения по ключу из хеш-таблицы можно использовать синтаксис</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">val</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">m</span><span class="tok-p">[</span><span class="tok-nx">key</span><span class="tok-p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Тогда, если ключ есть в хеш-таблице, то <code>val</code> будет присвоено значение, хранящееся по этому ключу, а в <code>ok</code> будет записано <code>true</code>. Если же ключ не найден, то <code>val</code> будет присвоено пустое значение, соответствующее типу значений хеш-таблицы, а в <code>ok</code> будет записано <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Таким образом, задачу можно решить следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">val</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">m</span><span class="tok-p">[</span><span class="tok-nx">key</span><span class="tok-p">]</span>
<span class="tok-k">if</span> <span class="tok-nx">ok</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">val</span>
<span class="tok-p">}</span>
<span class="tok-k">return</span> <span class="tok-nx">defaultValue</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Но в Go можно объединить первые две строки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">if</span> <span class="tok-nx">val</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">m</span><span class="tok-p">[</span><span class="tok-nx">key</span><span class="tok-p">];</span> <span class="tok-nx">ok</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">val</span>
<span class="tok-p">}</span>
<span class="tok-k">return</span> <span class="tok-nx">defaultValue</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Это особенно удобно потому, что во втором случае область видимости переменных <code>val</code> и <code>ok</code> будет ограничена условием, в первом же случае они оказываются объявлены за пределами условия.</p>
</div>
</div>
<div class="sect3">
<h4 id="_switch">Switch</h4>
<div class="paragraph">
<p>Для сопоставления значения выражения возможным значениям можно использовать оператор <code>switch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">switch</span> <span class="tok-p">&lt;</span><span class="tok-nx">expression</span><span class="tok-p">&gt;</span> <span class="tok-p">{</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">value</span> <span class="tok-mi">1</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">1</span><span class="tok-p">&gt;</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">value</span> <span class="tok-mi">2</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">2</span><span class="tok-p">&gt;</span>
<span class="tok-k">default</span><span class="tok-p">:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">3</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Если значение выражение совпадёт с одним из значений, будет выполнен соответствующий блок. При этом, если выражение совпадёт с несколькими значениями, будет выполнен только блок, соответствующий первому совпадению. Если значение выражения не совпадёт ни с одним из перечисленных значений, то будет выполнен блок <code>default</code>, которого может не быть.</p>
</div>
<div class="paragraph">
<p>Знакомые с такими языками как Си или JavaScript могут удивиться отсутствию ключевых слов <code>break</code> в конце блоков. В Go поведение по умолчанию противоположно поведению этих языков. По умолчанию выполняется только один блок. Если необходимо выполнить также и следующий блок, необходимо использовать ключевое слово <code>fallthrough</code>. Например,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">switch</span> <span class="tok-nx">command</span> <span class="tok-p">{</span>
<span class="tok-k">case</span> <span class="tok-s">&quot;save and continue&quot;</span><span class="tok-p">:</span>
    <span class="tok-nx">save</span><span class="tok-p">()</span>
    <span class="tok-k">fallthrough</span>
<span class="tok-k">case</span> <span class="tok-s">&quot;continue&quot;</span><span class="tok-p">:</span>
    <span class="tok-nx">next</span><span class="tok-p">()</span>
<span class="tok-k">default</span><span class="tok-p">:</span>
    <span class="tok-nx">save</span><span class="tok-p">()</span>
    <span class="tok-nx">stop</span><span class="tok-p">()</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном примере, если значение переменной <code>command</code> равно строке <code>"continue"</code>, то будет выполнена только функция <code>next</code>, если значение равно <code>"save and continue"</code>, то будет выполнена функция <code>save</code>, после чего будет выполнена следующая ветка, то есть <code>"continue"</code>, состоящая из вызова функции <code>next</code>. При любой другой команде будет выполнен блок <code>default</code>.</p>
</div>
<div class="paragraph">
<p>Если для нескольких значений необходимо выполнить одну и ту же последовательность инструкций, то можно записать это следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">switch</span> <span class="tok-nx">command</span> <span class="tok-p">{</span>
<span class="tok-k">case</span> <span class="tok-s">&quot;save and continue&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;save and next&quot;</span><span class="tok-p">:</span>
    <span class="tok-nx">save</span><span class="tok-p">()</span>
    <span class="tok-k">fallthrough</span>
<span class="tok-k">case</span> <span class="tok-s">&quot;continue&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;next&quot;</span><span class="tok-p">:</span>
    <span class="tok-nx">next</span><span class="tok-p">()</span>
<span class="tok-k">default</span><span class="tok-p">:</span>
    <span class="tok-nx">save</span><span class="tok-p">()</span>
    <span class="tok-nx">stop</span><span class="tok-p">()</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Часто конструкцию из множественных блоков <code>else if</code> переписывают в виде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">switch</span> <span class="tok-kc">true</span> <span class="tok-p">{</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">1</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">1</span><span class="tok-p">&gt;</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">2</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">2</span><span class="tok-p">&gt;</span>
<span class="tok-k">default</span><span class="tok-p">:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">3</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В Go в такой конструкции можно опустить выражение <code>true</code> вообще:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">switch</span> <span class="tok-p">{</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">1</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">1</span><span class="tok-p">&gt;</span>
<span class="tok-k">case</span> <span class="tok-p">&lt;</span><span class="tok-nx">condition</span> <span class="tok-mi">2</span><span class="tok-p">&gt;:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">2</span><span class="tok-p">&gt;</span>
<span class="tok-k">default</span><span class="tok-p">:</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">body</span> <span class="tok-mi">3</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
В отличии от других языков в Go использование конструкции <code>switch</code> не является анти-паттерном, однако длинных и, тем более, повторяющихся <code>switch</code>-ей стоит избегать, используя полиморфизм или хеш-таблицы.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_циклы">Циклы</h4>
<div class="paragraph">
<p>Одной из «фишек» Go является минимизация ключевых слов языка. Именно поэтому все циклы в нём определяются одним ключевым словом <code>for</code>. Но имеются следующие виды циклов:</p>
</div>
<div class="sect4">
<h5 id="_классический_си_подобный">Классический Си-подобный</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-mi">10</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь перед входом в цикл выполняется первая инструкция (<code>i := 0</code>), перед каждой итерацией цикла, в том числе и первой проверяется условие (<code>i &lt; 10</code>) и, если условие выполнено, то выполняется тело цикла, после чего выполняется вторая инструкция (<code>i++</code>), если же условие не выполнено, то цикл завершается и программа переходит к следующим инструкциям. Инструкции и условия могут быть более сложными, например</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">i</span><span class="tok-p">,</span> <span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-mi">100</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-p">,</span> <span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-nx">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-nx">a</span><span class="tok-o">+</span><span class="tok-nx">b</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_аналог_цикла_while">Аналог цикла <code>while</code></h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">x</span> <span class="tok-p">&lt;</span> <span class="tok-nx">y</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>По сути этот цикл можно написать как частный случай предыдущего, где обе инструкции пустые:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-nx">x</span> <span class="tok-p">&lt;</span> <span class="tok-nx">y</span><span class="tok-p">;</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Но Go позволяет в этом случае не писать лишние точки с запятыми.</p>
</div>
</div>
<div class="sect4">
<h5 id="_итерирование">Итерирование</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">i</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">m</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Это особый вид цикла, где после ключевого слова <code>range</code> может стоять выражение, результатом которого является строка, массив, срез, хеш-таблица или канал. Принцип действия для строк, массивов и срезов похож: для всех элементов этих объектов будет выполнено тело цикла, а переменная <code>i</code> будет принимать последовательно значения от 0 до длинны объекта без единицы, а <code>x</code> — значения хранящиеся в данном объекте по индексу <code>i</code>. Более подробно действие циклов такого типа будет рассмотрено в разделах, посвящённых <a href="#_срезы">срезам</a>, <a href="#_хеш_таблицы">хеш-таблицам</a> и <a href="#_каналы">каналам</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_бесконечный_цикл">Бесконечный цикл</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-p">{</span>
    <span class="tok-c1">// body</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Наконец, цикл с пустым условием аналогичен циклу с всегда истинным условием. Для выхода из такого цикла необходимо воспользоваться ключевыми словами <code>break</code> или <code>return</code>.</p>
</div>
<div class="paragraph">
<p>Также как и в других языках, в Go есть ключевые слова <code>continue</code> и <code>break</code>. Первое позволяет преждевременно завершить текущую итерацию цикла и перейти к следующей, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">sumOfPrimes</span> <span class="tok-o">:=</span> <span class="tok-mi">0</span>
<span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-mi">100</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">!</span><span class="tok-nx">isPrime</span><span class="tok-p">(</span><span class="tok-nx">i</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">continue</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">sumOfPrimes</span> <span class="tok-o">+=</span> <span class="tok-nx">i</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>С помощью ключевого слова <code>break</code> можно прекратить выполнение цикла. Однако, надо помнить, что это ключевое слово используется не только для прерывания цикла, но и для прерывания рассмотренной конструкции <code>switch</code> и конструкции из следующей главы <code>select</code>. Например, следующий код выведет все числа от 0 до 9:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-mi">10</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-k">switch</span> <span class="tok-nx">i</span> <span class="tok-p">{</span>
    <span class="tok-k">case</span> <span class="tok-mi">5</span><span class="tok-p">:</span>
        <span class="tok-k">break</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">i</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_функции">Функции</h3>
<div class="paragraph">
<p>Функции являются первым инструментом декомпозиции кода, разделения задачи на самодостаточные изолированные части. Подробнее о том как применять функции для решения задач обсудим в <a href="#_пример_вычисление_квадратного_корня_методом_ньютона">практической части этого раздела</a>, а пока сосредоточимся на синтаксисе. Определение функции всегда начинается с ключевого слова <code>func</code>, после чего возможно несколько вариантов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>именованная функция уровня пакета;</p>
</li>
<li>
<p>анонимная функция;</p>
</li>
<li>
<p>метод (в данном разделе мы пропустим этот вариант и вернёмся к нему в <a href="#_ооп_в_go">разделе, посвящённом ООП и методам</a>);</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Определение именованной функции уровня пакета мы с вами уже встречали:</p>
</div>
<div class="listingblock">
<div class="title">01_hello_world/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Hello, World!&quot;</span><span class="tok-p">)</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном примере функция не принимает аргументов и ничего не возвращает. Для более полного описания синтаксиса рассмотрим ещё несколько примеров:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-c1">// Вычисление квадрата числа</span>
<span class="tok-kd">func</span> <span class="tok-nx">square</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-kt">float64</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">*</span> <span class="tok-nx">x</span>
<span class="tok-p">}</span>

<span class="tok-c1">// Сумма чисел</span>
<span class="tok-kd">func</span> <span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span> <span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-kt">float64</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">+</span> <span class="tok-nx">y</span>
<span class="tok-p">}</span>

<span class="tok-c1">// Выравнивание строки по правому краю по заданной длине</span>
<span class="tok-kd">func</span> <span class="tok-nx">leftPad</span><span class="tok-p">(</span><span class="tok-nx">s</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">n</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">string</span> <span class="tok-p">{</span>
    <span class="tok-nx">pad</span> <span class="tok-o">:=</span> <span class="tok-s">&quot;&quot;</span>
    <span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">s</span><span class="tok-p">);</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-nx">n</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
        <span class="tok-nx">pad</span> <span class="tok-o">+=</span> <span class="tok-s">&quot; &quot;</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">pad</span> <span class="tok-o">+</span> <span class="tok-nx">s</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В общем виде определение функции можно описать так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">&lt;</span><span class="tok-nx">имя</span><span class="tok-p">&gt;(&lt;</span><span class="tok-nx">описание</span> <span class="tok-nx">аргументов</span><span class="tok-p">&gt;)</span> <span class="tok-p">&lt;</span><span class="tok-nx">описание</span> <span class="tok-nx">результата</span><span class="tok-p">&gt;</span> <span class="tok-p">{</span>
    <span class="tok-p">&lt;</span><span class="tok-nx">тело</span><span class="tok-p">&gt;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Перечисление аргументов функции очень похоже на определение переменных с помощью ключевого слова <code>var</code>, но в отличии от определения переменных, аргументам нельзя присваивать значение для инициализации, потому что при вызове функции необходимо передать все аргументы.</p>
</div>
<div class="sect3">
<h4 id="_кортеж_результатов">Кортеж результатов</h4>
<div class="paragraph">
<p>Функции могут возвращать не одно значение, а кортеж. В качестве примера возьмём функцию, которая принимает два аргумента и возвращает их в обратном порядке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">swap</span><span class="tok-p">(</span><span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span> <span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-kt">float64</span><span class="tok-p">,</span> <span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">y</span><span class="tok-p">,</span> <span class="tok-nx">x</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Типы результатов могут быть разными, а также можно именовать результаты, превращая их в объявление переменных. Это особенно удобно, когда не очевидно назначение результатов. При этом если использовать ключевое слово <code>return</code> без дополнительных аргументов, то будет возвращёны значения именованных результатов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">stripLeftSpaces</span><span class="tok-p">(</span><span class="tok-nx">s</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">result</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">trimmedSpaceCount</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">result</span> <span class="tok-o">:=</span> <span class="tok-nx">s</span>
    <span class="tok-k">for</span> <span class="tok-nx">result</span> <span class="tok-o">!=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">result</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-sc">&#39; &#39;</span> <span class="tok-p">{</span>
        <span class="tok-nx">result</span> <span class="tok-p">=</span> <span class="tok-nx">result</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:]</span>
        <span class="tok-nx">trimmedSpaceCount</span><span class="tok-o">++</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом совсем не обязательно использовать для возврата именно именованные результаты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">stripLeftSpaces</span><span class="tok-p">(</span><span class="tok-nx">s</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">result</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">trimmedSpaceCount</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-nx">trimmedSpaceCount</span> <span class="tok-p">&lt;</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">s</span><span class="tok-p">)</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">s</span><span class="tok-p">[</span><span class="tok-nx">trimmedSpaceCount</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-sc">&#39; &#39;</span><span class="tok-p">;</span> <span class="tok-nx">trimmedSpaceCount</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">s</span><span class="tok-p">[</span><span class="tok-nx">trimmedSpaceCount</span><span class="tok-p">:],</span> <span class="tok-nx">trimmedSpaceCount</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Присваивание в никуда</div>
<div class="paragraph">
<p>Бывает ситуации, когда из кортежа результатов, возвращаемых функцией, требуются не все. Тогда можно присвоить часть этого кортежа в никуда, точнее в специальную переменную <code>_</code>, куда можно записать всё что угодно, но ничего нельзя прочитать. Например, если нам необходимо убрать пробелы из начала строки, но не важно сколько их там было, можно написать:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">trimmedString</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">stripLeftSpaces</span><span class="tok-p">(</span><span class="tok-nx">s</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Подстановку <code>_</code> можно использовать не только для пропуска результатов, но в любом определении или присваивании переменных, в том числе и в аргументах функции.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_анонимные_функции">Анонимные функции</h4>
<div class="paragraph">
<p>В Go функции являются такими же данными, как переменные или константы. То есть функции можно передавать как аргументы в другие функции. Например, напишем функцию, находящую минимальное натуральное число (не включая 0), для которого выполнена некоторая проверка <code>check</code>, которая является функцией, принимающей целое число и возвращающей булево значение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">check</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span>
    <span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-p">!</span><span class="tok-nx">check</span><span class="tok-p">(</span><span class="tok-nx">i</span><span class="tok-p">);</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">i</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Функция <code>findMinimal</code> принимает один аргумент <code>check</code> с типом <code>func(x int) bool</code>. Под этот тип подойдут любые функции, принимающие один аргумент с типом <code>int</code> и возвращающие булево значение. Конечно, что то, как аргумент этой функции будет называться нем не важно. Поэтому имя аргумента можно опустить, сократив определение типа до <code>func(int) bool</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Теперь можно использовать эту функцию в комбинации с различными функциями проверки:</p>
</div>
<div class="listingblock">
<div class="title">02_find_minimal/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">check</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
	<span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span>
	<span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-p">!</span><span class="tok-nx">check</span><span class="tok-p">(</span><span class="tok-nx">i</span><span class="tok-p">);</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
	<span class="tok-p">}</span>
	<span class="tok-k">return</span> <span class="tok-nx">i</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">greatThan100</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
	<span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-p">&gt;</span> <span class="tok-mi">100</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">dividedBy11</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
	<span class="tok-k">return</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">11</span> <span class="tok-o">==</span> <span class="tok-mi">0</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">dividedBy11And13</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
	<span class="tok-k">return</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">11</span> <span class="tok-o">==</span> <span class="tok-mi">0</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">13</span> <span class="tok-o">==</span> <span class="tok-mi">0</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, больше 100:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">greatThan100</span><span class="tok-p">))</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, делимое на 11:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">dividedBy11</span><span class="tok-p">))</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, делимое на 11 и 13:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">dividedBy11And13</span><span class="tok-p">))</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Но иногда не хочется объявлять функции в глобальном пространстве имён. Тогда можно воспользоваться анонимными функциями, функциями без имени:</p>
</div>
<div class="listingblock">
<div class="title">03_find_minimal_anonymous/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">check</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
	<span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span>
	<span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-p">!</span><span class="tok-nx">check</span><span class="tok-p">(</span><span class="tok-nx">i</span><span class="tok-p">);</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
	<span class="tok-p">}</span>
	<span class="tok-k">return</span> <span class="tok-nx">i</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, больше 100:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
		<span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-p">&gt;</span> <span class="tok-mi">100</span>
	<span class="tok-p">}))</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, делимое на 11:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
		<span class="tok-k">return</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">11</span> <span class="tok-o">==</span> <span class="tok-mi">0</span>
	<span class="tok-p">}))</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, делимое на 11 и 13:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
		<span class="tok-k">return</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">11</span> <span class="tok-o">==</span> <span class="tok-mi">0</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">x</span><span class="tok-o">%</span><span class="tok-mi">13</span> <span class="tok-o">==</span> <span class="tok-mi">0</span>
	<span class="tok-p">}))</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы просто объявили функции в месте передачи их как аргументов, не давая им имена. Анонимную функцию можно присвоить переменной и даже вернуть как результат другой функции.</p>
</div>
</div>
<div class="sect3">
<h4 id="_замыкания">Замыкания</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">dividedBy</span><span class="tok-p">(</span><span class="tok-nx">d</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">%</span> <span class="tok-nx">d</span> <span class="tok-o">==</span> <span class="tok-mi">0</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Минимальное число, делимое на 11:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">findMinimal</span><span class="tok-p">(</span><span class="tok-nx">dividedBy</span><span class="tok-p">(</span><span class="tok-mi">11</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Получившаяся функция также называется <em>замыканием</em>, потому что ссылается на область видимости функции, которая её порождает (аргумент <code>d</code>). При этом в замыкании можно как читать, так и изменять контекст порождающей функции. С помощью замыканий можно реализовывать различные полезные паттерны проектирования. Например, с помощью замыкания можно создать итератор (объект возвращающий по запросу следующее значение из некоторой последовательности последовательности). Для примера напишем генератор чисел Фибоначчи:</p>
</div>
<div class="listingblock">
<div class="title">04_fibonacci/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">fibonacci</span><span class="tok-p">()</span> <span class="tok-kd">func</span><span class="tok-p">()</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
	<span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span>
	<span class="tok-k">return</span> <span class="tok-kd">func</span><span class="tok-p">()</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
		<span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-nx">a</span><span class="tok-o">+</span><span class="tok-nx">b</span>
		<span class="tok-k">return</span> <span class="tok-nx">a</span>
	<span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">iter</span> <span class="tok-o">:=</span> <span class="tok-nx">fibonacci</span><span class="tok-p">()</span>
	<span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-mi">10</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
		<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">iter</span><span class="tok-p">())</span>
	<span class="tok-p">}</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_рекурсия">Рекурсия</h4>
<div class="paragraph">
<p>Некоторые задачи требуют рекурсивного вызова функции. Например, вычисление факториала числа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">factorial</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">*</span> <span class="tok-nx">factorial</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Никогда не используйте приведённый выше способ вычисления факториала ни в одном языке. Используйте возможности стандартной библиотеки или используйте нерекурсивный вариант.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Несколько сложнее написать рекурсивную анонимную функцию, ведь для того, чтобы её вызвать необходимо знать её имя.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">factorial</span> <span class="tok-o">:=</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">*</span> <span class="tok-nx">factorial</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой вариант не скомпилируется, потому что компилятор сначала разбирает определение функции, а уже только после этого определение переменной <code>factorial</code>, то есть на момент разбора определения функции переменная <code>factorial</code> ещё не объявлена и мы не можем её использовать. Это можно обойти, разделив определение и присвоение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">factorial</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span>
<span class="tok-nx">factorial</span> <span class="tok-p">=</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">*</span> <span class="tok-nx">factorial</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь к моменту разбора тела функции переменная <code>factorial</code> уже объявлена и её можно использовать.</p>
</div>
</div>
<div class="sect3">
<h4 id="_функции_с_переменным_количеством_аргументов">Функции с переменным количеством аргументов</h4>
<div class="paragraph">
<p>Иногда возникает необходимость определить функцию, которая может принимать переменное число аргументов. Например, функция, суммирующая все переданные в неё аргументы. Вообще говоря мы можем передать в такую функцию один аргумент с типом срез (см. <a href="#_срезы">Срезы</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">args</span> <span class="tok-p">[]</span><span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-kt">float64</span> <span class="tok-p">{</span>
    <span class="tok-nx">res</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span>
    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">args</span> <span class="tok-p">{</span>
        <span class="tok-nx">res</span> <span class="tok-o">+=</span> <span class="tok-nx">x</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">res</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Но теперь, чтобы воспользоваться такой функцией нам будет необходимо в явном виде создавать срез и передавать его в качестве аргумента:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">sum</span><span class="tok-p">([]</span><span class="tok-kt">float64</span><span class="tok-p">{</span><span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">5</span><span class="tok-p">}))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В Go есть синтаксический сахар, позволяющий объявить последний аргумент функции как остаточный (rest):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">args</span> <span class="tok-o">...</span><span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-kt">float64</span> <span class="tok-p">{</span>
    <span class="tok-nx">res</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span>
    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">args</span> <span class="tok-p">{</span>
        <span class="tok-nx">res</span> <span class="tok-o">+=</span> <span class="tok-nx">x</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">res</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Внутри функции это будет такой же срез, как и был, зато снаружи можно будет передавать аргументы обычным кортежем:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">5</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот синтаксис имеет ряд ограничений, но часто позволяет улучшить публичный интерфейс пакета. Старайтесь не злоупотреблять подобным синтаксисом.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_задачи">Задачи</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Что будет результатом <code>--x</code>? Почему?</p>
</li>
<li>
<p>Предложите минимальное исправление для следующей программы:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">x</span><span class="tok-p">,</span> <span class="tok-nx">y</span> <span class="tok-kt">float64</span><span class="tok-p">)</span> <span class="tok-kt">float64</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">+</span> <span class="tok-nx">y</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">square</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nx">x</span> <span class="tok-o">*</span> <span class="tok-nx">x</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">square</span><span class="tok-p">(</span><span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-mi">25</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">)))</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Чему будет равна константа <code>Qux</code> при следующем определении:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Foo</span> <span class="tok-kt">uint32</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span> <span class="tok-o">*</span> <span class="tok-kc">iota</span>
    <span class="tok-nx">Bar</span>
    <span class="tok-nx">Baz</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span> <span class="tok-o">+</span> <span class="tok-mi">2</span>
    <span class="tok-nx">Qux</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p>Напишите генератор квадратов натуральных чисел.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сложные_типы_данных">Сложные типы данных</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Важной отличительной чертой скалярных типов является то, что при передаче их в качестве аргументов в функцию, на самом деле в функцию попадает копия объекта. Для наглядности рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="title">05_scalar_args/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">increment</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
	<span class="tok-nx">x</span><span class="tok-o">++</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">n</span> <span class="tok-o">:=</span> <span class="tok-mi">12</span>
	<span class="tok-nx">increment</span><span class="tok-p">(</span><span class="tok-nx">n</span><span class="tok-p">)</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">n</span><span class="tok-p">)</span> <span class="tok-c1">// 12</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>По факту переменные <code>n</code> и <code>x</code> будут указывать на разные участки оперативной памяти. В этой части мы рассмотрим типы данных, для которых это не так однозначно.</p>
</div>
<div class="sect2">
<h3 id="_структуры">Структуры</h3>
<div class="paragraph">
<p>Структуры в Go, как и в Си представляют из себя связанный набор переменных. Например, если в программе используется ФИО, будет полезно иметь тройку переменных, отвечающих за фамилию, имя и отчество:структура:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">fio</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Last</span><span class="tok-p">,</span> <span class="tok-nx">First</span><span class="tok-p">,</span> <span class="tok-nx">Middle</span> <span class="tok-kt">string</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Далее к полям этой структуры можно обращаться через точку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fio</span><span class="tok-p">.</span><span class="tok-nx">Last</span> <span class="tok-p">=</span> <span class="tok-s">&quot;Иванов&quot;</span>
<span class="tok-nx">fio</span><span class="tok-p">.</span><span class="tok-nx">First</span> <span class="tok-p">=</span> <span class="tok-s">&quot;Иван&quot;</span>
<span class="tok-nx">fio</span><span class="tok-p">.</span><span class="tok-nx">Middle</span> <span class="tok-p">=</span> <span class="tok-s">&quot;Иванович&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Как видно структура не является скалярным типом в нашем определении, потому что мы можем изменять изолированно часть данных, обращаясь к конкретному полю.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Пустым значением для переменной такого типа будет структура с пустыми значениями всех полей.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Если в нашей программе тройка ФИО встречается не единожды, удобно объявить новый тип данных, описывающий такую структуру:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">FIO</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Last</span><span class="tok-p">,</span> <span class="tok-nx">First</span><span class="tok-p">,</span> <span class="tok-nx">Middle</span> <span class="tok-kt">string</span>
<span class="tok-p">}</span>

<span class="tok-nx">fio</span> <span class="tok-o">:=</span> <span class="tok-nx">FIO</span><span class="tok-p">{</span>
    <span class="tok-nx">Last</span><span class="tok-p">:</span>   <span class="tok-s">&quot;Иванов&quot;</span><span class="tok-p">,</span>
    <span class="tok-nx">First</span><span class="tok-p">:</span>  <span class="tok-s">&quot;Иван&quot;</span><span class="tok-p">,</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что при создании объекта порядок полей может отличаться от порядка в объявлении типа, также могут быть перечисленны не все поля. Но можно не указывать имена полей, в таком случае порядок должен быть полностью совпадать с порядком объявления и пропуски запрещены:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fio</span> <span class="tok-o">:=</span> <span class="tok-nx">FIO</span><span class="tok-p">{</span><span class="tok-s">&quot;Иванов&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иван&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иванович&quot;</span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Пустая структура</div>
<div class="paragraph">
<p>Иногда в коде, написанном на Go, встречается следующая конструкция:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">myType</span> <span class="tok-kd">struct</span><span class="tok-p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kd">struct</span><span class="tok-p">{}{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Переменные такого типа не будут занимать память для данных, но сохранят привязку к типу. Это может пригодиться, например, для построения множеств с помощью <a href="#_хеш_таблицы">хеш-таблиц</a> или как приватный ключ для данных в <a href="#_context">контексте</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Теперь мы также можем передать переменную такого типа в функцию. И в этом случае поведение структуры похоже на поведение скалярных типов, создаётся копия переменной:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Animal</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Kind</span> <span class="tok-kt">string</span>
    <span class="tok-nx">Name</span> <span class="tok-kt">string</span>
    <span class="tok-nx">Age</span>  <span class="tok-kt">int</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">incrementAge</span><span class="tok-p">(</span><span class="tok-nx">animal</span> <span class="tok-nx">Animal</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">animal</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-o">++</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">Jackie</span> <span class="tok-o">:=</span> <span class="tok-nx">Animal</span><span class="tok-p">{</span>
        <span class="tok-nx">Kind</span><span class="tok-p">:</span> <span class="tok-s">&quot;dog&quot;</span><span class="tok-p">,</span>
        <span class="tok-nx">Name</span><span class="tok-p">:</span> <span class="tok-s">&quot;Джеки&quot;</span><span class="tok-p">,</span>
        <span class="tok-nx">Age</span><span class="tok-p">:</span>  <span class="tok-mi">17</span><span class="tok-p">,</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">incrementAge</span><span class="tok-p">(</span><span class="tok-nx">Jackie</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">Jackie</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-p">)</span> <span class="tok-c1">// 17</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Также при присваивании одной переменной другой будет происходить копирование:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">Copy</span> <span class="tok-o">:=</span> <span class="tok-nx">Jackie</span>
<span class="tok-nx">Copy</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-o">++</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">Jackie</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-p">)</span> <span class="tok-c1">// 17</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Для изменения данных структуры внутри функции можно воспользоваться указателями.</p>
</div>
</div>
<div class="sect2">
<h3 id="_указатели">Указатели</h3>
<div class="paragraph">
<p>Указатель это адрес данных в памяти. Если мы создадим копию этого адреса, он всё равно будет указывать на ту же область памяти. Таким образом при передаче указателя в качестве аргумента мы не создаём копию данных, копия указателя ссылается на те же данные. В Go существую только типизированные указатели, то есть они указывают на область памяти, где располагаются данные определённого типа. Этим типом может быть любой другой тип (кроме интерфейса, но об этом <a href="#_интерфейсы_и_полиморфизм">позже</a>). Для указания того, что переменная является указателем перед типом добавляется символ <code>*</code>. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">incrementAgeByPointer</span><span class="tok-p">(</span><span class="tok-nx">animal</span> <span class="tok-o">*</span><span class="tok-nx">Animal</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">animal</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-o">++</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Обращение к полям структуры не зависит от того, является ли переменная указателем или нет, но для других типов это не так. Например, если у нас есть указатель на число, то для работы с ним как с числом его необходимо разыменовать с помощью того же символа <code>*</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">incrementByPointer</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-o">*</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">x</span><span class="tok-p">)</span><span class="tok-o">++</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для того же, чтобы получить указатель на данные необходимо воспользоваться оператором <code>&amp;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">incrementAgeByPointer</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-nx">Jackie</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">Jackie</span><span class="tok-p">.</span><span class="tok-nx">Age</span><span class="tok-p">)</span> <span class="tok-c1">// 18</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Также при определении структуры можно вместо данных сразу получить указатель:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fio</span> <span class="tok-o">:=</span> <span class="tok-o">&amp;</span><span class="tok-nx">FIO</span><span class="tok-p">{</span><span class="tok-s">&quot;Иванов&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иван&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иванович&quot;</span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для других констант это невозможно, так что необходимо создавать переменную и получать указатель именно на неё:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">s</span> <span class="tok-o">:=</span> <span class="tok-s">&quot;some string&quot;</span>
<span class="tok-nx">p</span> <span class="tok-o">:=</span> <span class="tok-o">&amp;</span><span class="tok-nx">s</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Пустым значением для указателя является <code>nil</code>. Необходимо помнить, что <code>nil</code>-ы в Go являются типизированными. Подробнее об этом мы поговорим при обсуждении <a href="#_почему_nil_nil">интерфейсов</a>
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Пара слов о памяти</div>
<div class="paragraph">
<p>Стоит отметить, что указатель далеко не бесплатная переменная. Во-первых, в зависимости от системы он занимает в памяти 4 или 8 байт для 32- и 64-битных систем соответственно. Во-вторых, наличие указателя на определённые данные повышает вероятность того, что память для этих данных будет выделена в куче вместо стека, а соответственно это добавит работы <a href="#_сборка_мусора">сборщику мусора</a>. Однако для больших структур вероятность выделения памяти в куче и так велика, а дополнительные 8 байт на указатель могут в несколько раз быть меньше памяти, необходимой на копию. Использовать или не использовать указатель сильно зависит от контекста и нет единого правила. Если вы не уверены как поступить, положитесь на здравый смысл и <a href="#_линтеры_и_другие_инструменты">линтер</a>, например, <a href="https://go-critic.github.io/overview#hugeParam-ref"><code>go-critic</code></a> по умолчанию считает переломным моментом 80 байт.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_массивы">Массивы</h3>
<div class="paragraph">
<p>Массивы в Go похожи на тип array в Pascal. При описании типа мы должны указать количество и тип элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Point</span> <span class="tok-p">[</span><span class="tok-mi">2</span><span class="tok-p">]</span><span class="tok-kt">int</span>

<span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-nx">Point</span><span class="tok-p">{</span><span class="tok-mi">3</span><span class="tok-p">,</span> <span class="tok-mi">12</span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>С точки зрения хранения данных массив очень похож на структуру, где все поля имеют одинаковый тип и вместо имён полей используются индексы от 0 до n-1 (где n это количество элементов массива). Поэтому и ведут себя они также как структуры.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">О равенстве</div>
<div class="paragraph">
<p>Заметим, что все скалярные типы можно сравнивать на равенство. Если оба операнда имеют один тип и данные, хранящиеся в них равны, то отношение <code>==</code> вернёт истину. То же самое применимо и к структурам, и к массивам:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">ivan1</span> <span class="tok-o">:=</span> <span class="tok-nx">FIO</span><span class="tok-p">{</span><span class="tok-s">&quot;Иванов&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иван&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иванович&quot;</span><span class="tok-p">}</span>
<span class="tok-nx">ivan2</span> <span class="tok-o">:=</span> <span class="tok-nx">FIO</span><span class="tok-p">{</span><span class="tok-s">&quot;Иванов&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иван&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;Иванович&quot;</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">ivan1</span> <span class="tok-o">==</span> <span class="tok-nx">ivan2</span><span class="tok-p">)</span> <span class="tok-c1">// true</span>

<span class="tok-nx">p1</span> <span class="tok-o">:=</span> <span class="tok-nx">Point</span><span class="tok-p">{</span><span class="tok-mi">3</span><span class="tok-p">,</span> <span class="tok-mi">15</span><span class="tok-p">}</span>
<span class="tok-nx">p2</span> <span class="tok-o">:=</span> <span class="tok-nx">Point</span><span class="tok-p">{</span><span class="tok-mi">3</span><span class="tok-p">,</span> <span class="tok-mi">15</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">p1</span> <span class="tok-o">==</span> <span class="tok-nx">p2</span><span class="tok-p">)</span> <span class="tok-c1">// true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако, указатели на эти объекты не будут равны, потому что адреса в памяти у них разные:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-nx">ivan1</span> <span class="tok-o">==</span> <span class="tok-o">&amp;</span><span class="tok-nx">ivan2</span><span class="tok-p">)</span> <span class="tok-c1">// false</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-nx">p1</span> <span class="tok-o">==</span> <span class="tok-o">&amp;</span><span class="tok-nx">p2</span><span class="tok-p">)</span> <span class="tok-c1">// false</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Пустым значением для массива является массив пустых значений соответствующих типу элементов этого массива.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_итерирование_2">Итерирование</h4>
<div class="paragraph">
<p>Как упоминалось ранее, для массивов, строк и срезов есть особая форма цикла, позволяющая итерироваться по элементам (байтам в случае строки). Существует две формы этого цикла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[</span><span class="tok-mi">5</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>

<span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">a</span> <span class="tok-p">{</span>
    <span class="tok-c1">// i последовательно принимает значения от 0 до 4</span>
<span class="tok-p">}</span>

<span class="tok-k">for</span> <span class="tok-nx">i</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">a</span> <span class="tok-p">{</span>
    <span class="tok-c1">// i последовательно принимает значения от 0 до 4</span>
    <span class="tok-c1">// x копия i-го элемента</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_срезы">Срезы</h3>
<div class="paragraph">
<p>Конечно, при позиционировании Go как высокоуровневого языка, трудно обойтись только лишь массивами с фиксированным размером. Иногда невозможно предугадать количество данных и, как следствие, определить массив подходящего размера. В этом случае пригодится тип данных, называемый срез (slice). Объявляется он также как и массив, но изначально содержит ноль элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно объявить срез, уже наполненный какими-то элементами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">,</span> <span class="tok-mi">51</span><span class="tok-p">,</span> <span class="tok-mi">127</span><span class="tok-p">,</span> <span class="tok-mi">323</span><span class="tok-p">,</span> <span class="tok-mi">835</span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Но можно также добавить элементы в конец среза:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">2188</span><span class="tok-p">,</span> <span class="tok-mi">5798</span><span class="tok-p">,</span> <span class="tok-mi">15511</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом срез предоставляет удобный и гибкий тип данных, однако, есть несколько подводных камней, о которых надо помнить при работе со срезами. Для того, чтобы найти и понять эти нюансы, необходимо разобраться с внутренним устройством срезов.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Если вы знакомы с C++, то, скорее всего работали с таким типом данных, как <code>vector</code>. Срезы Go очень похожи по устройству и поведению на этот тип.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Все элементы среза лежат в памяти друг за другом также, как и в массиве. За счёт этого при работе с этими данными они легко кешируются процессором. Однако с этим связана проблема переноса данных. Представим, что у нас есть срез типа <code>[]int64</code>, в котором 5 элементов. Каждый элемент занимает 8 байт, значит весь набор занимает 40 последовательных байт в оперативной памяти.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="5-item-slice.png" alt="5 item slice" width="570" height="98">
</div>
</div>
<div class="paragraph">
<p>При этом память вокруг этих 40 байт может быть занята другими данными. Поэтому при добавлении даже одного элемента с помощью команды <code>append</code> может потребоваться зарезервировать новый участок памяти, перенести в него имеющиеся данные и дописать новый элемент. Операции аллокации памяти и копирования данных занимают много времени, поэтому резервировать необходимо с запасом. Обычно используется удвоение размера, то есть, даже если мы захотим дописать к срезу из 4 элементов ещё один, выгоднее зарезервировать 96 байт, вместо 48.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="12-item-slice.png" alt="12 item slice" width="840" height="98">
</div>
</div>
<div class="paragraph">
<p>Таким образом, у среза помимо данных есть две характеристики: длинна и вместимость. Длинна означает сколько фактически элементов лежит в памяти, а вместимость — под сколько элементов зарезервировано место. Узнать длину и вместимость среза можно с помощью функций <code>len</code> и <code>cap</code> соответственно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">),</span> <span class="tok-nb">cap</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// 5, 5</span>

<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">),</span> <span class="tok-nb">cap</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// 6, 12</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом перенос данных будет происходить только, если итоговый размер должен будет превзойти текущую вместимость. То есть в результате функции <code>append</code> адрес данных в памяти может измениться, а может нет. Именно поэтому функция <code>append</code> <em>не изменяет</em> переданный в неё срез, а возвращает обновлённый срез. При этом новый срез может использовать ту же память, что и оригинальный.</p>
</div>
<div class="sect3">
<h4 id="_пустой_срез">Пустой срез</h4>
<div class="paragraph">
<p>Одной из важных особенностей срезов является то, что срез может быть пустым, а может быть <code>nil</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span> <span class="tok-o">==</span> <span class="tok-kc">nil</span><span class="tok-p">)</span> <span class="tok-c1">// true</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">b</span> <span class="tok-o">==</span> <span class="tok-kc">nil</span><span class="tok-p">)</span> <span class="tok-c1">// false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Дело в том, что пустым значением для среза является <code>nil</code>. Но если мы объявим срез с пустым списком элементов, то получим не <code>nil</code>, а срез без элементов. При этом функция <code>append</code> ведёт себя одинаково.</p>
</div>
</div>
<div class="sect3">
<h4 id="_предварительное_резервирование_памяти">Предварительное резервирование памяти</h4>
<div class="paragraph">
<p>Итак, при добавлении элементов в срез возможен перенос данных. Это, как уже упоминалось, достаточно долгая операция. Часто мы можем предсказать сколько будет элементов или по крайней мере знаем верхнюю границу их количества. В этом случае можно создать срез с заранее выделенной памятью под данные. Для этого можно воспользоваться встроенной функцией <code>make</code>, доступной в двух вариантах записи:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nb">make</span><span class="tok-p">([]&lt;</span><span class="tok-kd">type</span><span class="tok-p">&gt;,</span> <span class="tok-p">&lt;</span><span class="tok-nx">len</span><span class="tok-p">&gt;)</span>
<span class="tok-nb">make</span><span class="tok-p">([]&lt;</span><span class="tok-kd">type</span><span class="tok-p">&gt;,</span> <span class="tok-p">&lt;</span><span class="tok-nx">len</span><span class="tok-p">&gt;,</span> <span class="tok-p">&lt;</span><span class="tok-nx">cap</span><span class="tok-p">&gt;)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>В первом случае будет создан срез с элементами типа <code>&lt;type&gt;</code> с длинной и вместимостью <code>&lt;len&gt;</code>, а во втором с длинной <code>&lt;len&gt;</code> и вместимостью <code>&lt;cap&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">([]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">12</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">),</span> <span class="tok-nb">cap</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// 0, 12</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">),</span> <span class="tok-nb">cap</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// 6, 12</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_копирование_среза">Копирование среза</h4>
<div class="paragraph">
<p>Можно представить срез как структуру с тремя полями: текущая вместимость, текущая длинна, указатель на область выделенной памяти. Тогда при копировании такой структуры будут созданы копии этих трёх полей, но область памяти с данными скопирована не будет и изменение данных в копии будет изменять данные оригинала:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nx">a</span>
<span class="tok-nx">b</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-mi">12</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1 12 2 4 9]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>А при расширении среза всё ещё куда менее предсказуемо:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nx">a</span> <span class="tok-c1">// копируем срез без запаса вместимости</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-mi">51</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1 1 2 4 9 21]</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nx">a</span> <span class="tok-c1">// копируем срез с запасом вместимости</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">51</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-mi">127</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1 1 2 4 9 21 127]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_копирование_данных">Копирование данных</h4>
<div class="paragraph">
<p>Для того, чтобы не попасться в подобную ловушку необходимо создать копию данных. Это можно сделать следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">([]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// создаём новый срез длинны a</span>
<span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">);</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
    <span class="tok-nx">b</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span>
<span class="tok-p">}</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">51</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-mi">127</span><span class="tok-p">)</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1 1 2 4 9 21 51]</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">)</span> <span class="tok-c1">// [1 1 2 4 9 21 127]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Вместо написания цикла можно воспользоваться встроенной функцией <code>copy(&lt;dst&gt;, &lt;src&gt;)</code>, которая копирует данные из <code>&lt;src&gt;</code> в <code>&lt;dst&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-mi">21</span><span class="tok-p">)</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">([]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span> <span class="tok-c1">// создаём новый срез длинны a</span>
<span class="tok-nb">copy</span><span class="tok-p">(</span><span class="tok-nx">b</span><span class="tok-p">,</span> <span class="tok-nx">a</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно помнить, что функция <code>copy</code> копирует элементов не больше, чем есть в <code>&lt;src&gt;</code> и для которых есть место в <code>&lt;dst&gt;</code>, то есть для среза <code>&lt;dst&gt;</code> необходимо заранее выделить память, например, с использованием функции <code>make</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_срез_среза">Срез среза</h4>
<div class="paragraph">
<p>Любопытный читатель может спросить, почему же срезы называются срезами, ведь пока они выглядят скорее как динамические массивы. Такое название определилось особым синтаксисом для получения части среза. Во многих языках есть функция или метод массива <code>slice(&lt;i&gt;[, &lt;j&gt;])</code>, которая возвращает кусочек оригинального массива от <code>i</code>-го элемента до <code>j-1</code>-го. В Go вместо функции для подобных выборок используется специальный синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:</span><span class="tok-mi">4</span><span class="tok-p">])</span> <span class="tok-c1">// [1, 2, 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно не указать начало среза, тогда срез будет взят от 0. Аналогично, если не указать конец среза, то срез будет взят до конца оригинального среза.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-mi">4</span><span class="tok-p">])</span> <span class="tok-c1">// [1, 1, 2, 4]</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:])</span> <span class="tok-c1">// [1, 2, 4, 9]</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[:])</span> <span class="tok-c1">// [1, 1, 2, 4, 9]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно помнить, что при этом не происходит копирования данных, то есть полученный срез указывает на тот же участок памяти, что и оригинальный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:</span><span class="tok-mi">4</span><span class="tok-p">]</span>
<span class="tok-nx">b</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-mi">12</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1, 12, 2, 4, 9]</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Режем всё</div>
<div class="paragraph">
<p>На самом деле синтаксис среза можно применять также к строкам и массивам. При этом срез строки будет строкой, а срез массива останется срезом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%T\n&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;test&quot;</span><span class="tok-p">[:])</span> <span class="tok-c1">// string</span>

<span class="tok-nx">arr</span> <span class="tok-o">:=</span> <span class="tok-p">[</span><span class="tok-mi">4</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%T\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">arr</span><span class="tok-p">[:])</span> <span class="tok-c1">// []int</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_переменные_параметры_для_функции">Переменные параметры для функции</h4>
<div class="paragraph">
<p>Помните, что последний параметр функции с типом срез можно определить с использованием <a href="#_функции_с_переменным_количеством_аргументов">rest-синтаксиса</a>. Мы также можем передать его с использованием подобного rest-синтаксиса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">args</span> <span class="tok-o">...</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-kd">var</span> <span class="tok-nx">res</span> <span class="tok-kt">int</span>
    <span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">args</span> <span class="tok-p">{</span>
        <span class="tok-nx">res</span> <span class="tok-o">+=</span> <span class="tok-nx">args</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">res</span>
<span class="tok-p">}</span>

<span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">sum</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-o">...</span><span class="tok-p">))</span> <span class="tok-c1">// 17</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Похожий интерфейс имеет функция <code>append</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">9</span><span class="tok-p">}</span>
<span class="tok-nx">b</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">21</span><span class="tok-p">,</span> <span class="tok-mi">51</span><span class="tok-p">,</span> <span class="tok-mi">127</span><span class="tok-p">,</span> <span class="tok-mi">323</span><span class="tok-p">,</span> <span class="tok-mi">835</span><span class="tok-p">}</span>

<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">b</span><span class="tok-o">...</span><span class="tok-p">))</span> <span class="tok-c1">// [1 1 2 4 9 21 51 127 323 835]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_slice_tricks">Slice tricks</h4>
<div class="paragraph">
<p>Несмотря на столь скромный набор встроенных методов по работе со срезами (<code>append</code>, <code>[i:j]</code>, <code>copy</code>), с их помощью можно производить достаточно сложные манипуляции, например, вставка элемента в <code>i</code>-ю позицию среза:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">,</span> <span class="tok-nx">x</span><span class="tok-p">)</span>
<span class="tok-nb">copy</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nx">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">],</span> <span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nx">i</span><span class="tok-p">])</span>
<span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-nx">x</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Или удаление <code>i</code>-го элемента:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nx">i</span><span class="tok-p">],</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">:]</span><span class="tok-o">...</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Другие операции над срезами вы можете найти в вики языка: <a href="https://github.com/golang/go/wiki/SliceTricks" class="bare">https://github.com/golang/go/wiki/SliceTricks</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_хеш_таблицы">Хеш-таблицы</h3>
<div class="paragraph">
<p>Хеш-таблицы, они же мапы, они же словари. Реализация этой структуры данных в Go заслуживает отдельной большой работы, потому что на сегодняшний день она одна из самых оптимальных в плане затрат памяти. Но в рамках этого курса мы не будем вдаваться в подробности реализации. Разберём только принцип работы, не зависящий от языка и реализации, и некоторые особенности поведения переменных этого типа в Go.</p>
</div>
<div class="paragraph">
<p><strong>Задача.</strong> Необходимо уметь хранить множество пар ключ-значение, так чтобы максимально эффективно реализовывались три операции:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>поиск по ключу;</p>
</li>
<li>
<p>добавление пары или изменение значения по ключу;</p>
</li>
<li>
<p>удаление пары по ключу;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Эту задачу можно решить различными структурами данных. Например, если ключи можно упорядочить, то применимы деревья поиска, которые помимо вышеописанных операций могут добавлять эффективные взятие диапазона ключей, слияние и другие. Но наиболее эффективно эти операции реализует хеш-таблица.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Как работают хеш-таблицы</div>
<div class="paragraph">
<p>В памяти выделяется монолитный участок для хранения \(N\) пар. Доступ к конкретной паре осуществляется по индексу. После этого для хеш-таблицы создаётся хеширующая функция, с помощью которой из ключа можно получить индекс в диапазоне \([0,N-1]\). Таким образом для всех операций ключ преобразовывается в индекс и работа ведётся как с массивом.</p>
</div>
<div class="paragraph">
<p>Конечно, возможны коллизии хеширующей функции, когда два разных ключа отображаются в один индекс. Существует несколько способов разрешения этих конфликтов. Подробнее про эти способы вы можете прочитать в книге Н. Вирта<a href="#virt">[virt]</a>. А в курсе Школы Анализа Данных<a href="#shad">[shad]</a> подробно разбирается устройство хеширующей функции.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Работу с хеш-таблицами продемонстрируем на примере нахождения самой часто-встречаемой буквы в тексте:</p>
</div>
<div class="listingblock">
<div class="title">06_most_frequent_rune/main.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">text</span> <span class="tok-o">:=</span> <span class="tok-s">`Welcome to a tour of the Go programming language. The tour is</span>
<span class="tok-s">divided into a list of modules that you can access by clicking on A Tour of Go</span>
<span class="tok-s">on the top left of the page. You can also view the table of contents at any</span>
<span class="tok-s">time by clicking on the menu on the top right of the page. Throughout the tour</span>
<span class="tok-s">you will find a series of slides and exercises for you to complete.`</span>
	<span class="tok-nx">counts</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">rune</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{}</span>
	<span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">c</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">text</span> <span class="tok-p">{</span>
		<span class="tok-k">switch</span> <span class="tok-nx">c</span> <span class="tok-p">{</span>
		<span class="tok-k">case</span> <span class="tok-sc">&#39; &#39;</span><span class="tok-p">,</span> <span class="tok-sc">&#39;.&#39;</span><span class="tok-p">:</span>
			<span class="tok-c1">// не будем учитывать эти символы в статистике</span>
		<span class="tok-k">default</span><span class="tok-p">:</span>
			<span class="tok-nx">counts</span><span class="tok-p">[</span><span class="tok-nx">c</span><span class="tok-p">]</span> <span class="tok-o">+=</span> <span class="tok-mi">1</span>
		<span class="tok-p">}</span>
	<span class="tok-p">}</span>
	<span class="tok-kd">var</span> <span class="tok-p">(</span>
		<span class="tok-nx">res</span> <span class="tok-kt">rune</span>
		<span class="tok-nx">max</span> <span class="tok-kt">int</span>
	<span class="tok-p">)</span>
	<span class="tok-k">for</span> <span class="tok-nx">c</span><span class="tok-p">,</span> <span class="tok-nx">count</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">counts</span> <span class="tok-p">{</span>
		<span class="tok-k">if</span> <span class="tok-nx">count</span> <span class="tok-p">&gt;</span> <span class="tok-nx">max</span> <span class="tok-p">{</span>
			<span class="tok-nx">res</span> <span class="tok-p">=</span> <span class="tok-nx">c</span>
			<span class="tok-nx">max</span> <span class="tok-p">=</span> <span class="tok-nx">count</span>
		<span class="tok-p">}</span>
	<span class="tok-p">}</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nb">string</span><span class="tok-p">(</span><span class="tok-nx">res</span><span class="tok-p">))</span> <span class="tok-c1">// преобразуем руну в строку, иначе будет выведен код</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для объявления переменной типа хеш-таблица используется выражение <code>map[&lt;тип ключа&gt;]&lt;тип значения&gt;</code>. Для чтения и записи по ключу используется синтаксис с указанием ключа в квадратных скобках. Важно отметить, что при чтении в таблице может не быть пары с данным ключом, тогда в качестве значения вернётся пустое значение, соответствующего типа. Если нам важно различать: есть ли ключ и по нему лежит пустое значение или пары с таким ключом нет, можно использовать расширенный синтаксис чтения: <code>val, ok := m[key]</code>, для первой ситуации переменной <code>ok</code> будет присвоена истина, для второй — ложь. Для удаления пары по ключу используется встроенная функция <code>delete(m, key)</code>.</p>
</div>
<div class="paragraph">
<p>Тип ключей должен поддерживать операции сравнения на равенство, к таким типам относятся все числовые типы и основанные на них, булевые, строки, указатели, каналы, интерфейсы, а также структуры и массивы, содержащие указанные типы. То есть нельзя использовать в качестве ключей функции, срезы и другие хеш-таблицы.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Почему хеш-таблицы называются map</div>
<div class="paragraph">
<p>Дело в том, что хеш-таблицы своего рода задают сопоставление множества ключей и множества значений, то есть, говоря математическим языком отображение множества ключей в множество значений. Частным случаем отображений являются хорошо знакомые нам математические функции. В английском языке для отображений используют термин <em>map</em>. Отсюда и название этой структуры.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_итерирование_3">Итерирование</h4>
<div class="paragraph">
<p>При итерировании по таблице возможны два варианта цикла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">for</span> <span class="tok-nx">key</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">m</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span>
<span class="tok-k">for</span> <span class="tok-nx">key</span><span class="tok-p">,</span> <span class="tok-nx">value</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">m</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>При этом во втором случае значения будут копироваться, то есть, если значения имеют не ссылочный тип, то изменение значения полученного в цикле не изменит значения, хранящегося в таблице:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{</span>
    <span class="tok-s">&quot;foo&quot;</span><span class="tok-p">:</span> <span class="tok-mi">5</span><span class="tok-p">,</span>
    <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">:</span> <span class="tok-mi">6</span><span class="tok-p">,</span>
    <span class="tok-s">&quot;baz&quot;</span><span class="tok-p">:</span> <span class="tok-mi">7</span><span class="tok-p">,</span>
<span class="tok-p">}</span>
<span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">value</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">m</span> <span class="tok-p">{</span>
    <span class="tok-nx">value</span><span class="tok-o">++</span>
<span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">m</span><span class="tok-p">)</span> <span class="tok-c1">// map[foo:5 bar:6 baz:7]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Для модификации необходимо использовать доступ по ключу или обновлять значение в таблице принудительно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{</span>
    <span class="tok-s">&quot;foo&quot;</span><span class="tok-p">:</span> <span class="tok-mi">5</span><span class="tok-p">,</span>
    <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">:</span> <span class="tok-mi">6</span><span class="tok-p">,</span>
    <span class="tok-s">&quot;baz&quot;</span><span class="tok-p">:</span> <span class="tok-mi">7</span><span class="tok-p">,</span>
<span class="tok-p">}</span>
<span class="tok-k">for</span> <span class="tok-nx">key</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">m</span> <span class="tok-p">{</span>
    <span class="tok-nx">m</span><span class="tok-p">[</span><span class="tok-nx">key</span><span class="tok-p">]</span><span class="tok-o">++</span>
<span class="tok-p">}</span>
<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">m</span><span class="tok-p">)</span> <span class="tok-c1">// map[foo:6 bar:7 baz:8]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_создание_хеш_таблиц">Создание хеш-таблиц</h4>
<div class="paragraph">
<p>Важно помнить про тот факт, что для работы хеш-таблицы необходимо выделить память для \(N\) пар. Без этого невозможно добавить в хеш-таблицу первую пару, то есть следующий код приведёт к ошибке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">var</span> <span class="tok-nx">m</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span>
<span class="tok-nx">m</span><span class="tok-p">[</span><span class="tok-s">&quot;foo&quot;</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-mi">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Это произойдёт потому, что таблицы также как и срезы являются ссылочным типом и при простом объявлении переменные этих типов оказываются указателями в никуда, то есть <code>nil</code>. При этом операции чтения будут валидны для этой переменной, в том числе итерирование будет выполнено ноль раз, как и ожидается, а взятие по ключу вернёт пустое значение и ложь в качестве второго возврата. Для того чтобы инициализировать таблицу для записи необходимо объявить её одним из следующих образов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Эти объявления эквивалентны. Рантайм Go не выделяет сразу большой объём памяти, вместо этого используется система бакетов или корзин, при которой по необходимости к хеш-таблице привязываются области памяти, называемые корзинами, в которых хранятся пары, и по необходимости количество корзин добавляется. Таким образом при инициализации хеш-таблицы без дополнительных указаний создаётся всего один бакет и вместе с заголовочной частью пустая таблица занимает 48 байт на 64-битной системе.</p>
</div>
<div class="paragraph">
<p>Если же вы заранее знаете о предполагаемом количестве пар, то можно дать рантайму подсказку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">m</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-mi">100</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Это будет только подсказка и рантайм может проигнорировать её, выделив меньше памяти. Однако, это хороший способ уменьшить число дополнительных дорогостоящих аллокаций памяти.</p>
</div>
<div class="paragraph">
<p>Также необходимо отметить, что для уменьшения количества коллизий таблице необходимо иметь достаточно свободного места. То есть помимо памяти, занятой парами, необходимо место, свободное для добавления. В среднем свободное место равно используемому месту под ключи. То есть, при использовании в качестве ключей <code>int64</code>, если в таблице находится 100 ключей, то примерно 80 байт выделено под ключи и столько же выделено под возможные вставки.</p>
</div>
</div>
<div class="sect3">
<h4 id="_передача_хеш_таблиц_качестве_параметров">Передача хеш-таблиц качестве параметров</h4>
<div class="paragraph">
<p>Хеш-таблицы всегда являются ссылками, поэтому они ведут себя также, как указатели. Это означает, что при передаче таблицы в качестве аргумента в функцию, будет передан по сути указатель на таблицу, и все изменения будут производиться на той же самой таблице.</p>
</div>
</div>
<div class="sect3">
<h4 id="_использование_хеш_таблиц_как_множеств">Использование хеш-таблиц как множеств</h4>
<div class="paragraph">
<p>Часто возникает потребность в получении множества каких-то объектов. Например, для удаления дубликатов. В этом случае можно использовать хеш-таблицу, используя объекты в качестве ключей. При этом значения нам не важны, важно понимать — есть уже объект в виде ключа в множестве или нет. Для удобства будем хранить там булево значение, записывая истину для добавляемых элементов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">unique</span><span class="tok-p">(</span><span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">[]</span><span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-nx">set</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">bool</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span>
    <span class="tok-nx">res</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">([]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span>
    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">a</span> <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-p">!</span><span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">]</span> <span class="tok-p">{</span>
            <span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-kc">true</span>
            <span class="tok-nx">res</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">res</span><span class="tok-p">,</span> <span class="tok-nx">x</span><span class="tok-p">)</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">res</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Если объектов очень много, то для экономии памяти можно в качестве значений использовать пустые структуры. При этом проверка на вхождение в объекта в множество становится несколько сложнее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-k">if</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">];</span> <span class="tok-p">!</span><span class="tok-nx">ok</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако, если нет задачи сохранять порядок, то код и с пустыми структурами останется простым и наглядным:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">unique</span><span class="tok-p">(</span><span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">[]</span><span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-nx">set</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kd">struct</span><span class="tok-p">{},</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span>
    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">a</span> <span class="tok-p">{</span>
        <span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-kd">struct</span><span class="tok-p">{}{}</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">res</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">([]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">set</span><span class="tok-p">))</span>
    <span class="tok-k">for</span> <span class="tok-nx">x</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">set</span> <span class="tok-p">{</span>
        <span class="tok-nx">res</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">res</span><span class="tok-p">,</span> <span class="tok-nx">x</span><span class="tok-p">)</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">res</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Пара слов о порядке</div>
<div class="paragraph">
<p>Хеш-функции, используемы в Go на самом деле формируют изоморфное отображение, то есть получаемые индексы имеют тот же порядок, что и ключи. Конечно, за исключением тех случаев, когда возникают коллизии, кои маловероятны на небольших объёмах данных. Таким образом при итерировании по хеш-таблицам ключи оказываются упорядочены. Это поведение не было описано в спецификации языка и могло измениться при изменении алгоритма хеш-функции. Однако, некоторые разработчики стали эксплуатировать это свойство. Предупреждая распространение этого в массово используемые библиотеки в версии 1.3 введена принудительная рандомизация порядка обхода хеш-таблиц.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_многомерные_хеш_таблицы">Многомерные хеш-таблицы</h4>
<div class="paragraph">
<p>Часто возникает задача разграничивать данные по нескольким признакам. Пусть, например, мы пишем систему групповых чатов, и нам необходимо кешировать счётчики непрочитанных сообщений. Для каждого пользователя и для каждого чата. Первое, что приходит в голову это сделать хеш-таблицу хеш-таблиц:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">counts</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">][</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>На первом уровне мы будем по идентификатору пользователя находить таблицу, в которой по идентификатору чата находить количество непрочитанных сообщений. При таком подходе возникает сложность при добавлении счётчика, потому что, необходимо выполнить дополнительную проверку: существует ли вложенная таблица для пользователя или необходимо создать новую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">inc</span><span class="tok-p">(</span><span class="tok-nx">counts</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">][</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-nx">userID</span><span class="tok-p">,</span> <span class="tok-nx">chatID</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">userCounts</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">counts</span><span class="tok-p">[</span><span class="tok-nx">userID</span><span class="tok-p">]</span>
    <span class="tok-k">if</span> <span class="tok-p">!</span><span class="tok-nx">ok</span> <span class="tok-p">{</span>
        <span class="tok-nx">userCounts</span> <span class="tok-p">=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">)</span>
        <span class="tok-nx">counts</span><span class="tok-p">[</span><span class="tok-nx">userID</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-nx">userCounts</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">userCounts</span><span class="tok-p">[</span><span class="tok-nx">chatID</span><span class="tok-p">]</span><span class="tok-o">++</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>С другой стороны есть решение этой задачи с использованием одного уровня таблицы. Для этого в качестве ключа используем пару: идентификатор пользовтаеля и идентификатор чата:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">CountKey</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">UserID</span><span class="tok-p">,</span> <span class="tok-nx">ChatID</span> <span class="tok-kt">int</span>
<span class="tok-p">}</span>
<span class="tok-nx">counts</span> <span class="tok-o">:=</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-nx">CountKey</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Тогда увеличение счётчика больше не требует дополнительных проверок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">inc</span><span class="tok-p">(</span><span class="tok-nx">counts</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">][</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">int</span><span class="tok-p">,</span> <span class="tok-nx">userID</span><span class="tok-p">,</span> <span class="tok-nx">chatID</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">counts</span><span class="tok-p">[</span><span class="tok-nx">CountKey</span><span class="tok-p">{</span><span class="tok-nx">userID</span><span class="tok-p">,</span> <span class="tok-nx">chatID</span><span class="tok-p">}]</span><span class="tok-o">++</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_каналы">Каналы</h3>
<div class="paragraph">
<p>TODO: каналы</p>
</div>
</div>
<div class="sect2">
<h3 id="_пример_сортировка_вставками">Пример: сортировка вставками</h3>
<div class="paragraph">
<p>В качестве примера напишем сортировку вставками. Вообще в стандартной библиотеке уже есть пакет <code>sort</code>, с помощью которого можно сортировать любые срезы и массивы. Однако, этот пример нам ещё пригодится.</p>
</div>
<div class="paragraph">
<p>Заметим, что сортировка не добавляет новых элементов в срез, так что мы можем передать срез в функцию сортировки как есть, переставить его элементы местами, и это будет применено к тому участку памяти, на который ссылается оригинальный срез.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><pre><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">func</span> <span class="tok-nx">sort</span><span class="tok-p">(</span><span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">{</span>
	<span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&lt;</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">);</span> <span class="tok-nx">i</span><span class="tok-o">++</span> <span class="tok-p">{</span>
		<span class="tok-nx">j</span> <span class="tok-o">:=</span> <span class="tok-nx">i</span>
		<span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-nx">j</span> <span class="tok-p">&gt;</span> <span class="tok-mi">0</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span> <span class="tok-p">&lt;</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">j</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">];</span> <span class="tok-nx">j</span><span class="tok-o">--</span> <span class="tok-p">{</span>
		<span class="tok-p">}</span>
		<span class="tok-k">for</span> <span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-p">&gt;</span> <span class="tok-nx">j</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">--</span> <span class="tok-p">{</span>
			<span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">],</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">],</span> <span class="tok-nx">a</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]</span>
		<span class="tok-p">}</span>
	<span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
	<span class="tok-nx">a</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">{</span><span class="tok-mi">12</span><span class="tok-p">,</span> <span class="tok-mi">8</span><span class="tok-p">,</span> <span class="tok-mi">22</span><span class="tok-p">,</span> <span class="tok-mi">11</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
	<span class="tok-nx">sort</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span>
	<span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span> <span class="tok-c1">// [1 3 8 11 12 22]</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_задачи_2">Задачи</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>В примере сдвиг отсортированной части массива при вставке производится в цикле (строки <code>[10:12]</code>). Оптимизируйте этот сдвиг при помощи встроенной функции <code>copy</code>.</p>
</li>
<li>
<p>Какую потенциальную проблему может вызвать следующий код?</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">unique</span><span class="tok-p">(</span><span class="tok-nx">a</span> <span class="tok-p">[]</span><span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-p">[]</span><span class="tok-kt">int</span> <span class="tok-p">{</span>
    <span class="tok-nx">set</span> <span class="tok-o">:=</span> <span class="tok-nb">make</span><span class="tok-p">(</span><span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">int</span><span class="tok-p">]</span><span class="tok-kt">bool</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">))</span>
    <span class="tok-k">for</span> <span class="tok-nx">i</span> <span class="tok-o">:=</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-nx">i</span> <span class="tok-o">&gt;=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-nx">i</span><span class="tok-o">--</span> <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">]</span> <span class="tok-p">{</span>
           <span class="tok-nb">copy</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nx">i</span><span class="tok-p">],</span> <span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nx">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">])</span>
           <span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-nx">a</span><span class="tok-p">[:</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">a</span><span class="tok-p">)</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">]</span>
        <span class="tok-p">}</span>
        <span class="tok-nx">set</span><span class="tok-p">[</span><span class="tok-nx">x</span><span class="tok-p">]</span> <span class="tok-p">=</span> <span class="tok-kc">true</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">a</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_тестирование">Тестирование</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_простой_тест">Простой тест</h3>

</div>
<div class="sect2">
<h3 id="_бенчмарки">Бенчмарки</h3>

</div>
<div class="sect2">
<h3 id="_вложенные_тесты">Вложенные тесты</h3>

</div>
<div class="sect2">
<h3 id="_property_based_тесты">Property-based тесты</h3>

</div>
<div class="sect2">
<h3 id="_задача_оптимизация_сортировки_вставками_бинарным_поиском">Задача: оптимизация сортировки вставками бинарным поиском</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_ооп_в_go">ООП в Go</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_методы">Методы</h3>

</div>
<div class="sect2">
<h3 id="_наследование">Наследование</h3>

</div>
<div class="sect2">
<h3 id="_интерфейсы_и_полиморфизм">Интерфейсы и полиморфизм</h3>
<div class="sect3">
<h4 id="_почему_nil_nil">Почему nil != nil?</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_пакеты_и_модули">Пакеты и модули</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_публичные_и_приватные_сущности">Публичные и приватные сущности</h3>

</div>
<div class="sect2">
<h3 id="_циклические_зависимости">Циклические зависимости</h3>

</div>
<div class="sect2">
<h3 id="_модули">Модули</h3>

</div>
<div class="sect2">
<h3 id="_соглашения">Соглашения</h3>
<div class="paragraph">
<p>internal, vendor, cmd, lib</p>
</div>
</div>
<div class="sect2">
<h3 id="_задача_развязать_циклические_зависимости">Задача: развязать циклические зависимости</h3>

</div>
<div class="sect2">
<h3 id="_стандартные_и_экспериментальные_пакеты">Стандартные и экспериментальные пакеты</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_конкурентное_программирование">Конкурентное программирование</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_go_рутины">Go-рутины</h3>

</div>
<div class="sect2">
<h3 id="_конкурентный_доступ_к_памяти">Конкурентный доступ к памяти</h3>
<div class="paragraph">
<p>atomic, mutex, Map</p>
</div>
</div>
<div class="sect2">
<h3 id="_csp_communicating_sequential_processes">CSP (Communicating sequential processes)</h3>

</div>
<div class="sect2">
<h3 id="_ожидание_завершения">Ожидание завершения</h3>
<div class="paragraph">
<p>WaitGroup, ErrGroup</p>
</div>
</div>
<div class="sect2">
<h3 id="_прерывание_пула_go_рутин">Прерывание пула go-рутин</h3>
<div class="sect3">
<h4 id="_context">Context</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_дополнительно">Дополнительно</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_обработка_ошибок">Обработка ошибок</h3>

</div>
<div class="sect2">
<h3 id="_потоки_reader_и_writer">Потоки (reader и writer)</h3>

</div>
<div class="sect2">
<h3 id="_рефлексия">Рефлексия</h3>

</div>
<div class="sect2">
<h3 id="_различные_подходы_к_тестированию">Различные подходы к тестированию</h3>

</div>
<div class="sect2">
<h3 id="_генерация_кода">Генерация кода</h3>

</div>
<div class="sect2">
<h3 id="_makefile_для_go_проектов">Makefile для Go-проектов</h3>

</div>
<div class="sect2">
<h3 id="_линтеры_и_другие_инструменты">Линтеры и другие инструменты</h3>

</div>
<div class="sect2">
<h3 id="_особые_комментарии">Особые комментарии</h3>

</div>
<div class="sect2">
<h3 id="_сборка_мусора">Сборка мусора</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_литература_и_ссылки">Литература и ссылки</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="kr"></a>[kr] Брайан Керниган и Деннис Ритчи. <em>Язык программирования C. Второе издание, переработанное и дополненное.</em>
Вильямс, 2019. — 288 с.</p>
</li>
<li>
<p><a id="cc"></a>[cc] Роберт Мартин. <em>Чистый код. Создание, анализ и рефакторинг.</em>
СПб.: Питер, 2018. — 464 с.</p>
</li>
<li>
<p><a id="virt"></a>[virt] Никлаус Вирт. <em>Алгоритмы и структуры данных.</em>
М.: ДМК Пресс, 2010. – 272 с.</p>
</li>
<li>
<p><a id="shad"></a>[shad] Максим Бабенко. <em>Алгоритмы и структуры данных.</em>
Учебный курс (видеолекции). — М.: Яндекс, 2012.
<a href="https://yandexdataschool.ru/edu-process/courses/algorithms" class="bare">https://yandexdataschool.ru/edu-process/courses/algorithms</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1.0<br>
Last updated 2020-02-10 09:18:56 +0400
</div>
</div>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments  { background: #f8f8f8; }
pre.pygments .tok-c { color: #408080; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #7D9029 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #A0A000 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>