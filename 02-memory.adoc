== Сложные типы данных

Важной отличительной чертой скалярных типов является то, что при передаче их в качестве аргументов в функцию, на самом деле в функцию попадает копия объекта. Для наглядности рассмотрим пример:

.05_scalar_args/main.go
[source,go]
----
include::examples/05_scalar_args/main.go[]
----

По факту переменные `n` и `x` будут указывать на разные участки оперативной памяти. В этой части мы рассмотрим типы данных, для которых это не так однозначно.

=== Структуры

Структуры в Go, как и в Си представляют из себя связанный набор переменных. Например, если в программе используется ФИО, будет полезно иметь тройку переменных, отвечающих за фамилию, имя и отчество:структура:
[source,go]
----
var fio struct {
    Last, First, Middle string
}
----
Далее к полям этой структуры можно обращаться через точку:
[source,go]
----
fio.Last = "Иванов"
fio.First = "Иван"
fio.Middle = "Иванович"
----
Как видно структура не является скалярным типом в нашем определении, потому что мы можем изменять изолированно часть данных, обращаясь к конкретному полю.

NOTE: Пустым значением для переменной такого типа будет структура с пустыми значениями всех полей.

Если в нашей программе тройка ФИО встречается не единожды, удобно объявить новый тип данных, описывающий такую структуру:
[source,go]
----
type FIO struct {
    Last, First, Middle string
}

fio := FIO{
    Last:   "Иванов",
    First:  "Иван",
}
----

Обратите внимание, что при создании объекта порядок полей может отличаться от порядка в объявлении типа, также могут быть перечисленны не все поля. Но можно не указывать имена полей, в таком случае порядок должен быть полностью совпадать с порядком объявления и пропуски запрещены:
[source,go]
----
fio := FIO{"Иванов", "Иван", "Иванович"}
----

.Пустая структура
****
Иногда в коде, написанном на Go, встречается следующая конструкция:
[source,go]
----
type myType struct{}
----
или
[source,go]
----
m := map[string]struct{}{}
----
Переменные такого типа не будут занимать память для данных, но сохранят привязку к типу. Это может пригодиться, например, для построения множеств с помощью <<_хеш_таблицы, хеш-таблиц>> или как приватный ключ для данных в <<Context, контексте>>.
****

Теперь мы также можем передать переменную такого типа в функцию. И в этом случае поведение структуры похоже на поведение скалярных типов, создаётся копия переменной:
[source,go]
----
type Animal struct {
    Kind string
    Name string
    Age  int
}

func incrementAge(animal Animal) {
    animal.Age++
}

func main() {
    Jackie := Animal{
        Kind: "dog",
        Name: "Джеки",
        Age:  17,
    }
    incrementAge(Jackie)
    fmt.Println(Jackie.Age) // 17
}
----

[NOTE]
====
Также при присваивании одной переменной другой будет происходить копирование:
[source,go]
----
Copy := Jackie
Copy.Age++
fmt.Println(Jackie.Age) // 17
----
====

Для изменения данных структуры внутри функции можно воспользоваться указателями.


=== Указатели

Указатель это адрес данных в памяти. Если мы создадим копию этого адреса, он всё равно будет указывать на ту же область памяти. Таким образом при передаче указателя в качестве аргумента мы не создаём копию данных, копия указателя ссылается на те же данные. В Go существую только типизированные указатели, то есть они указывают на область памяти, где располагаются данные определённого типа. Этим типом может быть любой другой тип (кроме интерфейса, но об этом <<_интерфейсы_и_полиморфизм, позже>>). Для указания того, что переменная является указателем перед типом добавляется символ `*`. Например:
[source,go]
----
func incrementAgeByPointer(animal *Animal) {
    animal.Age++
}
----
Обращение к полям структуры не зависит от того, является ли переменная указателем или нет, но для других типов это не так. Например, если у нас есть указатель на число, то для работы с ним как с числом его необходимо разыменовать с помощью того же символа `*`:
[source,go]
----
func incrementByPointer(x *int) {
    (*x)++
}
----

Для того же, чтобы получить указатель на данные необходимо воспользоваться оператором `&`:
[source,go]
----
incrementAgeByPointer(&Jackie)
fmt.Println(Jackie.Age) // 18
----

Также при определении структуры можно вместо данных сразу получить указатель:
[source,go]
----
fio := &FIO{"Иванов", "Иван", "Иванович"}
----

Для других констант это невозможно, так что необходимо создавать переменную и получать указатель именно на неё:
[source,go]
----
s := "some string"
p := &s
----

NOTE: Пустым значением для указателя является `nil`. Необходимо понмить, что `nil`-ы в Go являются типизированными. Подробнее об этом мы поговорим при обсуждении <<_почему_nil_nil, интерфейсов>>

.Пара слов о памяти
****
Стоит отметить, что указатель далеко не бесплатная переменная. Во-первых, в зависимости от системы он занимает в памяти 4 или 8 байт для 32- и 64-битных систем соответственно. Во-вторых, наличие указателя на определённые данные повышает вероятность того, что память для этих данных будет выделена в куче вместо стека, а соответственно это добавит работы <<_сборка_мусора, сборщику мусора>>. Однако для больших структур вероятность выделения памяти в куче и так велика, а дополнительные 8 байт на указатель могут в несколько раз быть меньше памяти, необходимой на копию. Использовать или не использовать указатель сильно зависит от контекста и нет единого правила. Если вы не уверены как поступить, положитесь на здравый смысл и <<_линтеры_и_другие_инструменты, линтер>>, например, <<https://go-critic.github.io/overview#hugeParam-ref, go-critic>> по умолчанию считает переломным моментом 80 байт.
****

=== Массивы

Массивы в Go похожи на тип array в Pascal. При описании типа мы должны указать количество и тип элементов:
[source,go]
----
type Point [2]int

x := Point{3, 12}
----

С точки зрения хранения данных массив очень похож на структуру, где все поля имеют одинаковый тип и вместо имён полей используются индексы от 0 до n-1 (где n это количество элементов массива). Поэтому и ведут себя они также как структуры.

.О равенстве
****
Заметим, что все скалярные типы можно сравнивать на равенство. Если оба операнда имеют один тип и данные, хранящиеся в них равны, то отношение `==` вернёт истину. То же самое применимо и к струтурам, и к массивам:
[source,go]
----
ivan1 := FIO{"Иванов", "Иван", "Иванович"}
ivan2 := FIO{"Иванов", "Иван", "Иванович"}
fmt.Println(ivan1 == ivan2) // true

p1 := Point{3, 15}
p2 := Point{3, 15}
fmt.Println(p1 == p2) // true
----

Однако, указатели на эти объекты не будут равны, потому что адреса в памяти у них разные:
[source,go]
----
fmt.Println(&ivan1 == &ivan2) // false
fmt.Println(&p1 == &p2) // false
----
****

NOTE: Пустым значением для массива является массив пустых значений соответствующих типу элементов этого массива.

==== Итерирование

Как упоминалось ранее, для массивов, строк и срезов есть особая форма цикла, позволяющая итерироваться по элементам (байтам в случае строки). Существует две формы этого цикла:
[source,go]
----
a := [5]int{1, 1, 2, 4, 9}

for i := range a {
    // i последовательно принимает значения от 0 до 4
}

for i, x := range a {
    // i последовательно принимает значения от 0 до 4
    // x копия i-го элемента
}
----

=== Срезы

Конечно, при позиционировании Go как высокоуровневого языка, трудно обойтись только лишь массивами с фиксированным размером. Иногда невозможно предугадать количество данных и, как следствие, аллоцировать массив подходящего размера. В этом случае пригодится тип данных, называемый срез (slice). Объявляется он также как и массив, но изначально содержит ноль элементов:
[source,go]
----
var a []int
----
Можно объявить срез, уже наполненный какими-то элементами:
[source,go]
----
a := []int{1, 1, 2, 4, 9, 21, 51, 127, 323, 835}
----

Но можно также добавить элементы в конец среза:
[source,go]
----
a = append(a, 2188, 5798, 15511)
----

Таким образом срез предоставляет удобный и гибкий тип данных, однако, есть несколько подводных камней, о которых надо понмить при работе со срезами. Для того, чтобы найти и понять эти нюансы, необходимо разобраться с внутренним устройством срезов.

NOTE: Если вы знакомы с C++, то, скорее всего работали с таким типом данных, как `vector`. Срезы Go очень похожи по устройству и поведению на этот тип.

Все элементы среза лежат в памяти друг за другом также, как и в массиве. За счёт этого при работе с этими данными они легко кешируются процессором. Однако с этим связана проблема релокации данных. Представим, что у нас есть срез типа `[]int64`, в котором 5 элементов. Каждый элемент занимает 8 байт, значит весь набор занимает 40 последовательных байт в оперативной памяти.
[ditaa,5-item-slice]
....
+-----+-------+-------+-------+-------+-------+-----+
|cPNK |cGRE 1 |cGRE 1 |cGRE 2 |cGRE 4 |cGRE 9 |cPNK |
+-----+-------+-------+-------+-------+-------+-----+
....

При этом память вокруг этих 40 байт может быть занята другими данными. Поэтому при добавлении даже одного элемента с помощью команды `append` может потребоваться зарезервировать новый участок памяти, перенести в него имеющиеся данные и дописать новый элемент. Операции аллокации памяти и копирования данных занимают много времени, поэтому резервировать необхоимо с запасом. Обычно используется удвоение размера, то есть, даже если мы захотим дописать к срезу из 4 элементов ещё один, выгоднее зарезервировать 96 байт, вместо 48.
[ditaa,12-item-slice]
....
+-----+-------+-------+-------+-------+-------+--------+-----+-----+-----+-----+
|cPNK |cGRE 1 |cGRE 1 |cGRE 2 |cGRE 4 |cGRE 9 |cGRE 21 |cYEL |cYEL |cYEL |cPNK |
+-----+-------+-------+-------+-------+-------+--------+-----+-----+-----+-----+
....

Таким образом, у среза помимо данных есть две характеристики: длинна и вместимость. Длинна означает сколько фактически элементов лежит в памяти, а вместимость — под сколько элементов зарезервированно место. Узнать длинну и вместимость среза можно с помощью функций `len` и `cap` соответственно:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
fmt.Println(len(a), cap(a)) // 5, 5

a = append(a, 21)
fmt.Println(len(a), cap(a)) // 6, 12
----

При этом релокация данных будет происходить только, если итоговый размер должен будет превзойти текущую вместимость. То есть в результате функции `append` адрес данных в памяти может измениться, а может нет. Именно поэтому функция `append` _не изменяет_ переданный в неё срез, а возвращает обновлённый срез. При этом новый срез может использовать ту же память, что и оригинальный.

==== Пустой срез

Одной из важных особенностей срезов является то, что срез может быть пустым, а может быть `nil`:
[source,go]
----
var a []int
b := []int{}
fmt.Println(a == nil) // true
fmt.Println(b == nil) // false
----

Дело в том, что пустым значением для среза является `nil`. Но если мы объявим срез с пустым списком элементов, то получим не `nil`, а срез без элементов. При этом функция `append` ведёт себя одинаково.

==== Преаллокация данных

Итак, при добавлении элементов в срез возможна релокация данных. Это, как уже упоминалось, достаточно долгая операция. Часто мы можем предсказать сколько будет элементов или по крайней мере не больше скольки их будет. В этом случае можно создать срез с заранее выделенной памятью под данные. Для этого можно воспользоваться встроенной функцией `make`, доступной в двух вариантах записи:
[source,go]
----
make([]<type>, <len>)
make([]<type>, <len>, <cap>)
----

В первом случае будет создан срез с элементами типа `<type>` с длинной и вместимостью `<len>`, а во втором с длинной `<len>` и вместимостью `<cap>`.
[source,go]
----
a := make([]int, 0, 12)
fmt.Println(len(a), cap(a)) // 0, 12
a = append(a, 1, 1, 2, 4, 9, 21)
fmt.Println(len(a), cap(a)) // 6, 12
----

==== Копирование среза

Можно представить срез как структуру с тремя полями: текущая вместимость, текущая длинна, указатель на область выделенной памяти. Тогда при копировании такой структуры будут созданы копии этих трёх полей, но область памяти с данными скопирована не будет и изменение данных в копии будет изменять данные оригинала:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
b := a
b[1] = 12
fmt.Println(a) // [1 12 2 4 9]
----

А при расширении среза всё ещё куда менее предсказуемо:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
b := a // копируем срез без запаса вместимости
a = append(a, 21)
b = append(b, 51)
fmt.Println(a) // [1 1 2 4 9 21]
----

[source,go]
----
a := []int{1, 1, 2, 4, 9}
a = append(a, 21)
b := a // копируем срез с запасом вместимости
a = append(a, 51)
b = append(b, 127)
fmt.Println(a) // [1 1 2 4 9 21 127]
----

==== Копирование данных

Для того, чтобы не попасться в подобную ловушку необходимо создать копию данных. Это можно сделать следующим способом:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
a = append(a, 21)
b := make([]int, len(a)) // создаём новый срез длинны a
for i := 0; i < len(a) && i < len(b); i++ {
    b[i] = a[i]
}
a = append(a, 51)
b = append(b, 127)
fmt.Println(a) // [1 1 2 4 9 21 51]
fmt.Println(b) // [1 1 2 4 9 21 127]
----

Вместо написания цикла можно воспользоваться встроенной функцией `copy(<dst>, <src>)`, которая копирует данные из `<src>` в `<dst>`:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
a = append(a, 21)
b := make([]int, len(a)) // создаём новый срез длинны a
copy(b, a)
----

Важно помнить, что функция `copy` копирует элементов не больше, чем есть в `<src>` и для которых есть место в `<dst>`, то есть срез `<dst>` обязательно нужно преалоцировать, например, с использованием функции `make`.

==== Срез среза

Любопытный читатель может спросить, почему же срезы называются срезами, ведь пока они выглядят скорее как динамические массивы. Такое название определилось особым синтаксисом для получения части среза. Во многих языках есть функция или метод массива `slice(<i>[, <j>])`, которая возвращает кусочек оригинального массива от `i`-го элемента до `j-1`-го. В Go вместо функции для подобных выборок используется специальный синтаксис:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
fmt.Println(a[1:4]) // [1, 2, 4]
----

Можно не указать начало среза, тогда срез будет взят от 0. Аналогично, если не указать конец среза, то срез будет взят до конца оригинального среза.
[source,go]
----
fmt.Println(a[:4]) // [1, 1, 2, 4]
fmt.Println(a[1:]) // [1, 2, 4, 9]
fmt.Println(a[:]) // [1, 1, 2, 4, 9]
----

Важно помнить, что при этом не происходит копирования данных, то есть полученный срез указывает на тот же участок памяти, что и оригинальный:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
b := a[1:4]
b[0] = 12
fmt.Println(a) // [1, 12, 2, 4, 9]
----

.Режем всё
****
На самом деле синтаксис среза можно применять также к строкам и массивам. При этом срез строки будет строкой, а срез массива останется срезом:
[source,go]
----
fmt.Printf("%T\n", "test"[:]) // string

arr := [4]int{0, 1, 2, 3}
fmt.Printf("%T\n", arr[:]) // []int
----
****

==== Переменные параметры для функции

Помните, что последний параметр функции с типом срез можно определить с использованием <<_функции_с_переменным_количеством_аргументов, rest-синтаксиса>>. Мы также можем передать его с использованием подобного rest-синтаксиса:
[source,go]
----
func sum(args ...int) int {
    var res int
    for i := range args {
        res += args[i]
    }
    return res
}

a := []int{1, 1, 2, 4, 9}
fmt.Println(sum(a...)) // 17
----

Похожий интерфейс имеет функция `append`:
[source,go]
----
a := []int{1, 1, 2, 4, 9}
b := []int{21, 51, 127, 323, 835}

fmt.Println(append(a, b...)) // [1 1 2 4 9 21 51 127 323 835]
----

==== Slice tricks

Несмотря на столь скромный набор встроенных методов по работе со срезами (`append`, `[i:j]`, `copy`), с их помощью можно производить достаточно сложные манипуляции, например, вставка элемента в `i`-ю позицию среза:
[source,go]
----
a = append(a, x)
copy(a[:i+1], a[:i])
a[i] = x
----

Или удаление `i`-го элемента:
[source,go]
----
a = append(a[:i], a[i+1:]...)
----

Дргуие операции над срезами вы можете найти в вики языка: https://github.com/golang/go/wiki/SliceTricks.

=== Хеш-таблицы

=== Каналы

=== Пара слов об оформлении кода

=== Пример: сортировка вставками