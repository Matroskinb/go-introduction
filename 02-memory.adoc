== Сложные типы данных

Важной отличительной чертой скалярных типов является то, что при передаче их в качестве аргументов в функцию, на самом деле в функцию попадает копия объекта. Для наглядности рассмотрим пример:

.05_scalar_args/main.go
[source,go]
----
include::examples/05_scalar_args/main.go[]
----

По факту переменные `n` и `x` будут указывать на разные участки оперативной памяти. В этой части мы рассмотрим типы данных, для которых это не так однозначно.

=== Структуры

Структуры в Go, как и в Си представляют из себя связанный набор переменных. Например, если в программе используется ФИО, будет полезно иметь тройку переменных, отвечающих за фамилию, имя и отчество:структура:
[source,go]
----
var fio struct {
    Last, First, Middle string
}
----
Далее к полям этой структуры можно обращаться через точку:
[source,go]
----
fio.Last = "Иванов"
fio.First = "Иван"
fio.Middle = "Иванович"
----
Как видно структура не является скалярным типом в нашем определении, потому что мы можем изменять изолированно часть данных, обращаясь к конкретному полю.

Если в нашей программе тройка ФИО встречается не единожды, удобно объявить новый тип данных, описывающий такую структуру:
[source,go]
----
type FIO struct {
    Last, First, Middle string
}

fio := FIO{
    Last:   "Иванов",
    First:  "Иван",
}
----

Обратите внимание, что при создании объекта порядок полей может отличаться от порядка в объявлении типа, также могут быть перечисленны не все поля. Но можно не указывать имена полей, в таком случае порядок должен быть полностью совпадать с порядком объявления и пропуски запрещены:
[source,go]
----
fio := FIO{"Иванов", "Иван", "Иванович"}
----

.Пустая структура
****
Иногда в коде, написанном на Go, встречается следующая конструкция:
[source,go]
----
type myType struct{}
----
или
[source,go]
----
m := map[string]struct{}{}
----
Переменные такого типа не будут занимать память для данных, но сохранят привязку к типу. Это может пригодиться, например, для построения множеств с помощью <<_хеш_таблицы, хеш-таблиц>> или как приватный ключ для данных в <<Context, контексте>>.
****

Теперь мы также можем передать переменную такого типа в функцию. И в этом случае поведение структуры похоже на поведение скалярных типов, создаётся копия переменной:
[source,go]
----
type Animal struct {
    Kind string
    Name string
    Age  int
}

func incrementAge(animal Animal) {
    animal.Age++
}

func main() {
    Jackie := Animal{
        Kind: "dog",
        Name: "Джеки",
        Age:  17,
    }
    incrementAge(Jackie)
    fmt.Println(Jackie.Age) // 17
}
----

[NOTE]
====
Также при присваивании одной переменной другой будет происходить копирование:
[source,go]
----
Copy := Jackie
Copy.Age++
fmt.Println(Jackie.Age) // 17
----
====

Для изменения данных структуры внутри функции можно воспользоваться указателями.


=== Указатели

Указатель это адрес данных в памяти. Если мы создадим копию этого адреса, он всё равно будет указывать на ту же область памяти. Таким образом при передаче указателя в качестве аргумента мы не создаём копию данных, копия указателя ссылается на те же данные. В Go существую только типизированные указатели, то есть они указывают на область памяти, где располагаются данные определённого типа. Этим типом может быть любой другой тип (кроме интерфейса, но об этом <<_интерфейсы_и_полиморфизм, позже>>). Для указания того, что переменная является указателем перед типом добавляется символ `*`. Например:
[source,go]
----
func incrementAgeByPointer(animal *Animal) {
    animal.Age++
}
----
Обращение к полям структуры не зависит от того, является ли переменная указателем или нет, но для других типов это не так. Например, если у нас есть указатель на число, то для работы с ним как с числом его необходимо разыменовать с помощью того же символа `*`:
[source,go]
----
func incrementByPointer(x *int) {
    (*x)++
}
----

Для того же, чтобы получить указатель на данные необходимо воспользоваться оператором `&`:
[source,go]
----
incrementAgeByPointer(&Jackie)
fmt.Println(Jackie.Age) // 18
----

Также при определении структуры можно вместо данных сразу получить указатель:
[source,go]
----
fio := &FIO{"Иванов", "Иван", "Иванович"}
----

Для других констант это невозможно, так что необходимо создавать переменную и получать указатель именно на неё:
[source,go]
----
s := "some string"
p := &s
----

.Пара слов о памяти
****
Стоит отметить, что указатель далеко не бесплатная переменная. Во-первых, в зависимости от системы он занимает в памяти 4 или 8 байт для 32- и 64-битных систем соответственно. Во-вторых, наличие указателя на определённые данные повышает вероятность того, что память для этих данных будет выделена в куче вместо стека, а соответственно это добавит работы сборщику мусора. Однако для больших структур вероятность выделения памяти в куче и так велика, а дополнительные 8 байт на указатель могут в несколько раз быть меньше памяти, необходимой на копию. Использовать или не использовать указатель сильно зависит от контекста и нет единого правила.
****

=== Массивы

Массивы в Go похожи на тип array в Pascal. При описании типа мы должны указать количество и тип элементов:
[source,go]
----
type Point [2]int

x := Point{3, 12}
----

С точки зрения хранения данных массив очень похож на структуру, где все поля имеют одинаковый тип и вместо имён полей используются индексы от 0 до n-1 (где n это количество элементов массива). Поэтому и ведут себя они также как структуры.

.О равенстве
****
Заметим, что все скалярные типы можно сравнивать на равенство. Если оба операнда имеют один тип и данные, хранящиеся в них равны, то отношение `==` вернёт истину. То же самое применимо и к струтурам, и к массивам:
[source,go]
----
ivan1 := FIO{"Иванов", "Иван", "Иванович"}
ivan2 := FIO{"Иванов", "Иван", "Иванович"}
fmt.Println(ivan1 == ivan2) // true

p1 := Point{3, 15}
p2 := Point{3, 15}
fmt.Println(p1 == p2) // true
----

Однако, указатели на эти объекты не будут равны, потому что адреса в памяти у них разные:
[source,go]
----
fmt.Println(&ivan1 == &ivan2) // false
fmt.Println(&p1 == &p2) // false
----
****

=== Срезы

=== Хеш-таблицы

=== Каналы

=== Пара слов об оформлении кода

=== Пример: сортировка вставками