== Базовый синтаксис

Начнём с избитой фразы: «Go является статически компилируемым в машинный код языком с сильной статической типизацией». А теперь давайте по порядку разбираться, что же всё это означает. Если вам и так всё понятно, смело переходите параграфу <<_hello_world>>.

Вообще компьютер умеет работать только с так называемым машинным кодом, то есть инструкциями для центрального процессора, закодированных в понятные этому процессору коды. При этом одна инструкция языка, например, `print("Hello, World")` разворачивается в несколько инструкций для процессора. Программа, на каком бы языке она ни была написана в итоге должна превратиться в инструкции, понятные процессору. Но пути этого превращения различны. Языки могут быть _компилируемые_ и _интерпретируемые_. У компилируемых языков этап превращения исходного кода в инструкции процессора, называемый _компиляцией_, отделён от этапа исполнения этих инструкций. В интерпретируемых языках это преобразование делается непосредственно перед исполнением. Стоит отметить, что в Go есть сокращённая форма для компиляции и запуска: `go run main.go`, выглядящая со стороны как запуск интерпретатора.

С другой стороны даже процесс компиляции может быть разделён на различные этапы. Так есть языки с _виртуальными машинами_, такие как Java, Erlang, JavaScript и многие другие. Программы, написанные на этих языках компилируются в инструкции виртуального процессора, который эмулируется соответствующей виртуальной машиной, которая на своём уровне преобразует эти инструкции в понятные физическому процессору. То есть вводится промежуточное представление программы, не зависящее от архитектуры конечного компьютера. С другой стороны промежуточное представление программы может быть и без виртуальной машины, например, многие языки используют промежуточное LLVM-представление.

В случае интерпретируемых языков для запуска необходим интерпретатор и все зависимости. Артефакты же компиляции могут быть _динамическими_ или _статическими_. Статический исполняемый файл содержит все свои зависимости в себе и не требует установки дополнительных пакетов или библиотек на компьютер, где будет исполняться. С другой стороны динамические ссылки в исполняемом файле дают большую гибкость в настройке уже во время исполнения, позволяя подменять части программы динамически подключаемыми библиотеками.

Осталась последняя часть фразы: _сильная статическая типизация_. В любом языке программирования есть типы, как бы от вас это не скрывалось его синтаксисом, при этом указание типов никак не связано с тем является ли система типов языка сильной или слабой, статической или динамической. _Сильной_ системой типов (иногда её также называют строгой) делает ограничение на взаимодействие между типами, например, нельзя сложить строку и число, а в Go нельзя умножить целое число на дробное. Однако, можно выполнить приведение типа:

[source,go]
----
var x int = 12
var y float64 = 2.2

var res float64 = float64(x) + y
----

Также как и с компиляцией, преобразование типов операндов производится в любом языке, но в слабо типизированных языках есть набор правил, по которым компилятор или интерпретатор может выполнить часть преобразований без явных инструкций со стороны программиста. Несмотря на то, что это похоже на то, как мы думаем, ведь написанное на бумаге «426» мы без труда интерпретируем и как строку и как число, хоть целое, хоть вещественное, часто такие неявные правила приводят к трудно обнаружимым ошибкам ошибкам.

_Динамическая_ и _статическая_ типизация также различается ограничениями, так при статической типизации тип приписывается переменной один раз и не может быть изменён. Например, следующий код допустим в Python (сильная динамическая типизация), но не допустим в Go:

[source,python]
----
x = "foo"
x = 5
----

Все приведённые выше развилки имеют достоинства и недостатки с обоих сторон. Нельзя сказать, что компилируемые языки лучше или хуже интерпретируемых. Для некоторых задач что-то больше подходит, что-то меньше. Из своего опыта могу лишь сказать, что в долгосрочной перспективе компиляция и строгая статическая типизация помогают уберечься от глупых ошибок, хоть по началу и требуют больше времени для написания кода.

=== Hello, World!

Продолжим следовать избитым клише и первой программой будет «Привет, Мир!». Создайте файл с именем `hello_world.go` со следующим содержимым:

.hello_world.go
[source,go,linenums]
----
include::examples/hello_world/hello_world.go[]
----

Теперь, если выполнить в командной строке (в директории с файлом `hello_world.go`) команду
----
go run hello_world.go
----
вы должны увидеть вывод нашей программы:
----
Hello, World!
----

NOTE: Все примеры, используемые в данном курсе, можно найти в директории examples в репозитории проекта {github}.



=== Переменные

=== Управление потоком выполнения

=== Функции

=== Константы и глобальная область видимости

=== Задача: вычисление квадратного корня методом Ньютона
